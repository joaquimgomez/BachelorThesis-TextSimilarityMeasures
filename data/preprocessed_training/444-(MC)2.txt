refficientlib: effici load-rebalanc adapt mesh refin algorithm high-perform comput physic mesh | siam journal scientif comput | vol. 39, no. 2 | societi industri appli mathemat copyright siam. unauthor reproduct articl prohibited. siam j. sci. comput. c 2017 societi industri appli mathemat vol. 39, no. 2, pp. c65c95 refficientlib: effici load-rebalanc adapt mesh refin algorithm high-perform comput physic mesh joan baig camilo bayona abstract. paper present novel algorithm adapt mesh refin compu- tation physic mesh distribut memori parallel setting. propos method develop nodal base parallel domain partit node mesh belong singl processor, element belong multipl processors. main featur algorithm present paper capabl handl multipl type element dimens (triangular, quadrilateral, tetrahedral, hexahedral), small memori requir processor, parallel scalabl thousand processors. present algorithm capabl deal nonbalanc hierarch refinement, multirefin level jump possibl neighbor elements. algorithm deal load rebalanc presented, allow hierarch data structur processor load unbalanc kept accept level time simulation. particular featur propos algorithm arbitrari renumb algorithm load rebalanc step, includ graph partit space-fil renumb algorithms. present algorithm pack fortran 2003 object orient librari refficientlib, in- terfac call allow comput physic code summarized. finally, numer experi illustr perform scalabl algorithm presented. kei words. adapt mesh refinement, adaptivity, finit elements, finit volumes, finit differ- ences, high-perform computing, parallel, load rebalanc am subject classifications. 68u01, 68u20 doi. 10.1137/15m105330x 1. introduction. discret partial differenti equat solv type practic problem engin physics. prob- lems, solut lead wide rang spatial scale spread compu- tation domain. cases, numer solut obtain coars mesh inaccurate, perform comput fine mesh impracti- cal consid requir comput effort. adapt mesh refin (amr) method deal issu produc effici mesh capabl resolv- ing wide rang scales. method local adjust mesh improv solut minim comput effort. develop parallel amr method justifi order solv problem contain larg number unknown typic requir us huge comput resources. parallel refin method allow exploit calcul capabl provid rapidli evolv parallel com- puter clusters. however, parallel refin method lead distribut mesh submit journal softwar high-perform comput section decemb 17, 2015; accept public (in revis form) novemb 17, 2016; publish electron march 30, 2017. funding: work partial support spanish govern elastic-flow project dpi2015-67857-r. author work support spanish govern ramon y cajal grant ryc-2015-17367. second author support doctor scholarship re- ceiv colombian government-colciencias. centr internacion metod numer lenginyeria (cimne), edifici c1, campu nord upc c/ gran capita s/n, 08034 barcelona, spain, universitat politecnica catalunya, jordi girona 1-3, edifici c1, 08034 barcelona, spain c65 d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. c66 joan baig camilo bayona structure, complex frequent data access necessary, memori consumpt high. addition, dynam evolut inform amr constitut major challenge: requir grow number collect commun operations, easili scalabl massiv parallel computers. includ possibl redistribut workload processor order maxim util comput resourc significantli increas commun demand. hence, effici algorithm data structur be- come backbon parallel amr methods, distribut collect structur dynam modifi requir global commun prefer designs. approach parallel amr method block-structur methods. method refin parallel mesh singl sequenti mapping, suitabl complex geometri nonstructur meshes. tree-bas meth- od altern regular impos block-structur methods. tree data structures, quadtre octrees, hierarch data structur construct axis-align line planes. data structur search procedur hierarch structur reduc complex search. applic tree data structur algorithm parallel domain decomposit effici partit mesh (see, example, camp- bell et al. [7]). later, data structures, balanc algorithms, adapt refin algorithm distribut octre mesh develop [19, 20]. etre li- brari [22] collect algorithm address oper octree-bas mesh database-ori framework. code demonstr good scalabl par- allel efficiency. furthermore, octre develop implement octor parallel mesh tool [21], gener static unstructur mesh processor perform dynam refin execut time. scalabl test address 62,000 processor hexahedra give overal good performance. multigrid solver exploit balanc mesh algorithm octree-bas mesh implement dendro softwar [17]. code scale thousand processors. applic multipl implemen- tation base octre data structur develop [16, 15] possess good adapt performance. instead quadrilater cube-shap domain describ tree data structures, wider varieti geometri describ forest-of-octre base meshes. approach introduc amr method deal.ii softwar [3], code replic global mesh processors, limit scalabl processors. fulli distribut algorithm han- dling forest-of-octre mesh follow step. burstedd et al. [5] work dynam amr base distribut forest-of-octre geometries. work support high-ord discret non-cartesian geometries, led encapsul algorithm p4est librari [6]. good, strong, weak scale result 224,000 core obtain p4est work paral- lel adapt refin librari mesh compos quadrilater hexahedr element [3]. later, isaac, burstedde, ghatta [11] focus balanc struc- ture propos subtre balanc algorithm. weak scale time improv requir memori previou balanc algorithm p4est . paper gener adapt finit element framework un- structur mesh demonstr suitabl perform larg scale parallel computations. algorithm current focus h-refinement; extens algorithm hp-refin matter futur work. contrari paral- d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. refficientlib: effici adapt mesh refin c67 lel refin algorithms, method present develop nodal base parallel domain partitions; is, node mesh belong singl proces- sor, element belong multipl processor node belong differ subdomains. remot node set overlap element call ghost points. pose challeng parallel communications, neighbor parallel domain need kept updated. hence, local elements, points, edges, faces, connect store data structur eas- ili access modified. refin oper load balanc procedur handl structures. best knowledge, libmesh [14] similar approximation. how- ever, complet unstructur method work cost have store explicitli connect mesh, parallel partit scheme libmesh store mesh inform processor, associ overhead limit scalabl 100 processors. jansson, hoffman, jansson [12] im- plement gener adapt finit element framework unstructur tetrahedr mesh hang nodes, suitabl larg scale parallel computa- tions. author present strong scale result linear 1,000 processor incompress flow solver. contrast, main contribut propos refin framework following: 1. hierarch adapt refin algorithm nodal base partit distribut memori machin presented. algorithm allow suc- cessiv refin unrefin comput mesh order adapt requir simulation. 2. distribut structur handl two- three-dimension unstructur mesh compos triangular, quadrilateral, tetrahedral, hexahedr elements. approach capabl describ complex geometri perform nonuniform refinements. 3. propos distribut scheme processor store local inform partit distribut mesh. reduc memori consumpt allow scale thousand processors. 4. parallel refin procedur base hierarch data structur refin element mesh us effici search neighbor element interprocessor level. data structur contain parent children pointer used, new refin level success ad subtract comput mesh. 5. result mesh nonconform hang node side level refin meet. contrari adapt refin methods, algorithm propos enforc balanc restrict re- finement level adjac elements: jump refin level neighbor element arbitrarili large. 6. parallel refin process, propos algorithm deal element node identif processor global element global point identifi structure. ensur global number structur gener nodal element inform transfer neighbor processor effici manner. 7. balanc processor load, us dynam parallel repartit framework chang ownership mesh node load unbal- anc reach certain threshold, transfer associ element correspond processors. contrari algorithm load rebal- anc hierarch amr, algorithm propos independ d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. c68 joan baig camilo bayona renumb strategi load rebalanc process. particular, graph partit scheme space-fil method load rebalanc propos algorithm. propos algorithm pack adapt refin librari refficientlib. call librari simpl possibl easili coupl exist finit element, volume, differ codes. numer test carri order assess perform propos methods. group test correspond simul driven experi illustr capabl method gener comput mesh differ physic problems. poisson heat transfer problem solv bidimension three-dimension elements. incompress flow past cylind test order appli amr incompress navierstok equations. second group experiments, weak scalabl test uniform refin load balanc case high-perform comput environ presented. paper organ follows. section 2 distribut refin structur mesh partit strategy, distribut data structures, initializa- tion refin procedure, described. section 3 refin step described. classification, local refinement, hang nodes, export ex- ternal flat mesh algorithm presented. load rebalanc global renumb procedur includ section 4. extern call user interfac refficientlib librari extern comput physic solver present section 5. numer experi scalabl test present section 6. finally, section 7 conclus stated. 2. distribut refin structure. section dis- tribut structur amr method. domain partit strategi explain first, parallel developed. introduc main data structur initi step parallel amr method. 2.1. mesh partition. algorithm describ paper design work distribut memori parallel machines. idea librari take care step necessari refinement, extern driver (for instance, finit element solver) see result mesh nonhierarch flat grid. domain partit strategi mesh nodal based, mean node assign uniqu processor, element belong multipl processor node subdomain. concept point node refer node mesh, node gener deal point element, point treat independ entities. point belong given subdomain denot local points. refinement, node assign singl processor, layer node belong neighbor processor store current processor. neighbor point call ghost points. element belong multipl processor node multipl subdomains. defin processor respons element processor own node element lowest global node number. figur 1 show initi domain partit mesh seen differ pro- cessors. advantag strategi processor store local inform subdomain. processor store local numer sub- domain points, global number point save order locat commun point processors. parallel refin method construct partit mesh. mesh need seen flat mesh extern driver, node element d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. refficientlib: effici adapt mesh refin c69 fig. 1. initi mesh information. left: global mesh. point element (circled) number globally. right: mesh, partit subdomains. color denot processor inform belongs. point element (circled) number local domain. note element number (2), (3), (6), (10) global mesh share subdomains. distribut structur calcul remot neighbor contribut share elements. (see onlin version color.) fig. 2. intern hierarch mesh seen processors. order illustr refin example, share element mesh figur 1 refined. left: initi level 0 mesh. right: refin level 1 mesh. renumb strategi need order abl external, flat mesh intern (refiner) hierarch mesh vice versa. figur 2 present exampl hierarch refin mesh. level refin displai seen intern refin processors. mesh depict figur 3 seen extern driver. note element mark asterisk () figur 2 appear flat mesh consid processor: extern flat mesh, layer flat node neighbor considered, intern hierarch mesh, element hierarch neighbor considered. element hierarch neighbor element share parent element belong processor. element mark asterisk () figur 2 hierarch neighbor, node assign processor, element share parent rest level 1 element processor. element share parent sibl elements. 2.2. distribut data structures. algorithm describ section 3 implement collect data structur allow effici d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. c70 joan baig camilo bayona fig. 3. refin mesh seen extern driver. left: extern flat mesh. right: extern flat mesh seen processor denot blue color. (see onlin version color.) access modifi inform defin mesh. implement gener object-ori manner, effici actual storag memori us flatten storage, part object store arrai list. denot storag structur csr, refer compact spars row storag comput physic applications. data structur encapsul class, refiner. refin procedur commun perform class. data structur refin class briefli explain follows: gnpoin total number point intern mesh. gnelem total number element intern mesh. npoin number point intern mesh local proces- sor. includ local (belong current processor) point (npoinlocal) layer hierarch neighbor local point (npoinghost). npoinloc number point intern global mesh belong current processor. npoinghost number point intern global mesh layer hierarch neighbor local nodes. data requir current processor. nelem number element intern mesh requir current processor. includ element have local node element local node relev hierarch refin process. elementlist list element local numbering, size nelem. local element need store contain elementtype. item identifi element type (triangles, quadri- laterals, tetrahedra, hexahedra) subtyp variat accord subdivis process. subtyp relevant, instance, case tetrahedr elements, multipl possibl hierarch subdivid element. store arrai 1 byte integ dimens 2. d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. refficientlib: effici adapt mesh refin c71 data structur type globalelementidentifier. similarli strategi follow [3], global element identifi allow uniqu identifi element mesh (describ subsect 2.3). parentidentifier. local element number parent element. childrenidentifierlist. list local element number children elements. (store csr format.) nodelist. contain node element lo- cal numbering. store arrai 4 byte integ dimens 2. (store csr format.) facelist. face element, store neighbor (opposite) element correspond face (or edg dimensions) neighbor. hang face, contain neighbor parent element correspond face. (store csr format.) pointlist list node local numbering, size npoin. npoinloc compon list correspond local points, npoinghost compon list correspond ghost points. point, store following: globalpointnumbering. data structur store global (par- allel) point number point. inverseglobalpointnumber- inglist creat allow local point number global point given processor. order implement invers global point number list, hash tabl type structur (thi describ subsect 2.4). processornumber. ghost points, store processor number point belongs. level. level (in refin structure) point. initi point classifi level 0. edgerefinementlist. point i, store list neighbor point j point connect refin node k j exists; store local number j k. (store csr format.) hangingnodelist. hang nodes, contain list recurs parent node linear combin coefficients. (store csr format.) list involv multipl type data (i.e., elementlist pointlist) implement separ list arrai conveni memori performance, store object contain data structures. size compon list constant elements, separ list arrai gener store csr format. 2.3. globalelementidentifi data structure. hierarch refine- ment element inform encapsul tree data structur compos globalelementidentifi objects. data structur allow uniqu iden- tifi element processor, level refinement. parentidentifi childrenidentifierlist, allow communi- cate element inform processors. inform identifi local number element interprocessor inform commun required. globalelementidentifi structur compos follow information: d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. c72 joan baig camilo bayona globaltoplevelelement. origin element number level element prior refin load rebalanc process. store 4 byte integer. level. level element refin structure. initi element classifi level 0. store 1 byte integer. positioninparentelement. level, bit dedic store refin branch (or child) element. allow identifi maximum children level. maximum 21 refin level allow current implementation, total 63 bits. store 8 byte integer. total memori requir store globalelementidentifi element 13 bytes, round 16 byte memory. 2.4. inverseglobalpointnumberinglist. order perform parallel communications, need abl recov local point number global point identifi time refin process. straight- forward manner alloc arrai dimens gnpoin store local point, global posit array, local number associ cor- respond global point. however, gnpoin depend size global problem gener large. result alloc arrai time consum and, thousand processors, affect perform scalabl parallel refin algorithm. thus, altern implement global local map required. implementation, opt implement hash filter follow binari search collis found. first, hash function defin modulu divis primer number primenumber, close larger local number point npoinlocal. hash tabl data structur dimens primenum- ber allocated. second, local pointglob point pair, hash function global point identifi comput point store correspond hash tabl data structur slot. collisions, point store ascend order accord global point identifier. finally, order recov local number global point, hash function global point number computed. singl point store correspond hash tabl slot, local number recov directly. case collisions, binari search perform sort global point number arrai hash tabl slot order correspond local point number. process allow reduc averag comput cost find local point number associ global point o(1), keep storag require- ment o(npoinlocal). possibl effici implement differenti behavior algorithm local ghost points, chosen describ implement compromis effici reusability. 2.5. initialization. parallel refin method establish input ini- tial mesh zero level mesh coarsened. initi step, flat, level mesh pass refiner. mesh, elementlist pointlist built. element point assign zero level. processor number point global element number element d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. refficientlib: effici adapt mesh refin c73 point need pass refiner, globalelementidentifi element globalpointnumb (and inverse) point built. initi facelist element built loop neigh- bor element check face coincid nodes. neighbor element identifi step process element point shared. remain arrays, refer refin structure, start null, refin step perform yet. 3. refin step. 3.1. amend element refin classification. stage refin step consist pass librari arrai size nelem contain inform element refinement. implement achiev pass 1 valu integ element need refined, 1 valu integ element need unrefined, 0 valu integ element need refin unrefined. element unrefin sibl element unrefined. element mark unrefin sibl not, element reclassifi unrefined. import point refin criteria pro- cessors; is, element belong processor j, decis refin element coincid processor processor j. take account, unrefin case inform avail certain processor decid element ef- fectiv unrefined. is, instance, situat unrefin step level 1 element figur 2 3. suppos extern driver mark level 1 element export extern mesh (figur 3) unrefined. however, blue processor (figur 3, right) inform classif hierarch neighbor (mark asterisk () figur 2). consequence, case local element sibl mark unrefined, commun step neighbor processor requir order classifi hierarch neighbor elements. commun step consist ask processor respons el- ement commun refin classification. element differ processor identifi globalelementidentifier. step requir refining, sibl element refin independently. explain previously, propos algorithm deal unbalanc mesh sens refin level jump neighbor element arbitrar- ili large. however, conveni applications. this, option flag limit level jump neighbor element ad algorithm. flag enabled, algorithm add follow previou reclassif element refined: node, note maximum minimum level element belongs. then, differ maximum minimum level 1 (the algorithm allow differ larger 1), allow maximum level element refine, allow minimum level element unrefine. ensur balanc mesh obtain case flag enabled. 3.2. local refinement. element properli classifi follow refin criteria, local refin step start processor. implement subdivis process triangles, quadrilaterals, tetrahedrons, hexahedron re- d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. c74 joan baig camilo bayona fig. 4. subdivis tetrahedron tetrahedron octahedron. octahedron subdivid tetrahedrons. fine given element 2d subel type, d number dimensions, implement left open refin element type future. loop element allow comput di- mension arrai refin stage, allocated. element unrefin remov lists, new element ad end elementlist. time, parentidentifi chil- drenidentifierlist element filled. globalelementidentifi new element comput globalelementidentifi parent element (ad level parent level, assign child number new level). element type comput (for h-refinement, element type chil- dren element parent element type). case tetrahedrons, element subtyp need stored: refin tetrahedron subdivid subelements. however, differ wai subdivid tetra- hedron subelements, wai correspond main plane subdivis intern octahedron obtain join midpoint tetrahedron edges. elect subel type distort result children element minimized. illustr figur 4. updat facelist element, neighbor element checked. previou refin step face connect element unrefin current refin step, element connect parent element. contrary, element connect higher level element refined, element connect correspond- ing children. face connect effici manner thank parent-identifi childrenidentifierlist structures, allow differ refin levels. exampl face match element differ level shown figur 5. face connect face element higher level denot hang faces. point, element refin structur updat new refin stage. however, new node need ad new elements. type node new elements: node ad edg d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. refficientlib: effici adapt mesh refin c75 fig. 5. face match refin process. mesh start refin process (top), element b face connect element a, level higher. similarly, element d face connect face element c. refin step, element c b refin (bottom). children b face connect face element a, face element d connect element c connect face children element c. parent element, node ad face parent element, node ad interior parent element. best illustr three-dimension hexahedr elements, shown figur 6. node ad interior parent element, sure node new, new point number assign node. however, node ad face edg parent element, need check node exist element. case node ad face elements, node pre-exist face new child element connect element level. case new node new child element assign point number node neighbor face. node ad edg elements, us edgerefine- mentlist structure, edg connect point mesh store point number refin point ad them. keep track exist refin point edges, allow add new point element refin or, contrary, match exist point refin point edge. addit new node edgerefine- mentlist need step process (the loop count size allocating, second loop fill data structures) make us link list order obtain proper perform algorithm. 3.3. parallel numbering. algorithm step previou subsect allow advanc new refin mesh. however, commun processors, stage new point assign local d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. c76 joan baig camilo bayona fig. 6. edg (red), face (blue), interior (green) new node refin element. (see onlin version color.) numbering, parallel number point pending. elements, hand, identifi globalelementidentifier. order construct new global point numbering, start classifi point local ghost processor. point exist previou refin stage local/ghost status. new point classifi local ghost follow differ criteria depend new interior points, new face points, new edg points. new interior point classifi local given processor if, previou refin step, processor owner node parent element lowest global number (the processor respons processor element). new face point classifi local given processor if, previou refin step, processor owner node parent face lowest global number (the processor respons processor face). new edg point classifi local given processor if, previou refin step, processor owner node parent edg lowest global number (the processor respons processor edge). point processor classifi local ghost, gather oper number local point processor, follow scatter opera- tion global point number processor, allow set parallel global number local point processor (sinc global number- ing local point processor consecutive). however, parallel number ghost point processor unknown processor. point ghost previou refin step, processor simpli ask owner point commun new global number. ask point, point identifi global number previou refin step. new ghost points, global number obtain follows: new interior face points, globalelementidentifi parent element sent respons processor interior/fac node number, turn return global point number interior point. new edg points, old (previou refin step) global number edg parent point sent processor respons edge, turn seek refin edg point edgerefinementlist return new point global number new edg point. stage, intern refin structur defin updat d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. refficientlib: effici adapt mesh refin c77 new refin stage. step export inform extern mesh detail follow subsections. 3.4. hang nodes. refin algorithm tree data structur conform restrict adjac element satisfied, case algorithm. so-cal balanc condition, enforc fact hang node side level refin meet, need satisfi algorithm present paper, arbitrari jump refin level adjac element possible. believ main featur present algorithm. hang node classifi node belong face edg connect element higher level (hang face edge) belong higher level element. possibl treat hang node comput physics: possibl approxim hang node consist fix valu unknown hang node mean valu unknown hang parent (thi approach follow numer examples). possibl includ us discontinu galerkin method [8] hybrid continuous-discontinu galerkin method [2]. case, necessari know hang parent certain hang node. hang parent defin node parent element case interior refin nodes, node parent face case face refin nodes, node parent edg case edg refin nodes. hang parent turn hang nodes, establish recurs depend valu unknown hang node valu unknown higher level nodes. implementation, list hang node relat respect hang parent obtain loop element check node match face edg connect higher level elements. node present side face, element concur edge, consid hang nodes. hang node list built, recurs depend structur re- spect hang parent obtain travers hang node list level low level hang node annot contribut hang parent averag valu hang node. number parent contribut averag valu hang node arbitrarili larg balanc condit applied, recurs depend structur store csr format. parent node hang node hang node, contribut valu hang node transfer recurs hang parents. illustr figur 7. note success refin steps, normal node hang node depend refin behavior neighbor element vice versa. 3.5. export extern mesh. explain previously, hierarch mesh algorithm work intern coincid flat mesh export extern driver. main criteria choos element node pass extern mesh following: element export level element local node. node export belong export element. criteria gener suffici decid element need exported. however, specif case (after load rebalanc occur children element necessarili processor parent ele- d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. c78 joan baig camilo bayona fig. 7. hang nodes. node 4 hang node, hang parent node 2 3. node 3 turn hang node, hang parent node 1 2. hang node valu unknown node 4 u4 = 1 2 u3 + 1 2 u2 = 1 4 u1 + 3 4 u2. ments) addit element need exported. case hang node hang parent node assign differ processor, il- lustrat figur 8. case, element own recurs hang parent need export order ensur assembl parent node perform ensur high level element refined, involv processor awar refin step. second case element hang opposit element node assign current processor. node element belong current processor, element need export refin criteria known current processor new element face match created. again, exampl particular case seen figur 8. cases, inform element belong neighbor processor present current processor commun processors. case element b figur 8. 4. load rebalancing. refin steps, comput load processor unbalanced, caus load processor damag global efficiency. order avoid issue, load rebalanc required. load rebalanc consist chang processor own group node wai comput load approxim equal processors. time, ensur commun requir load rebalanc process extern comput perform driver minimized. 4.1. rebal renumbering. step load rebalanc process consist comput new processor new global number node mesh. contrari adapt refin scheme new node number- ing link adapt refin algorithm, algorithm present paper node renumb strategi possible. fact, new node number comput extern driver pass refin library. numer exampl present section 6, node renumb comput extern parmeti [13] zoltan [4] special software, base nest bisection, graph partitioning, space-fil methods. pack- ag access interfac provid petsc librari [1], us linear solver numer exampl section 6. d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. refficientlib: effici adapt mesh refin c79 fig. 8. left: global export mesh. center: local export mesh processor 0 (blue nodes). right: local export mesh processor 1 (red nodes). element principl export processor 0, local node processor, export hang opposit element belong processor 0. element b principl export processor 1, local node processor, export hang opposit element belong processor 1. (see onlin version color.) remap method produc new partit partit mesh. node mesh assign processor number belong, remain decid element node need sent processor. algorithm rule step similar rule export element node subsect 3.5, take account hierarch natur intern mesh follows: element need sent processor own node belong processor. element need sent processor children sibl element sent processor. node need sent processor belong element sent processor. again, addit rule appli case element hang nodes: element high level hang (edg face) opposit element need sent given processor sent processor. situat similar depict figur 8. 4.2. rebuild refin structure. final step refin readi continu follow step amr strategi con- sist rebuild requir data structures. facelist structur parentidentifi childrenidentifierlist arrai rebuilt step process inform nodelist travers element level globalelementidentifi element. done, rebuild- ing hangingnodelist edgerefinementlist straightforward, care need taken result implement efficient. 5. extern call refficientlib library. section present interfac call refficientlib object-ori library. implemen- d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. c80 joan baig camilo bayona tation allow refin algorithm distribut memori compu- tation physic codes. librari develop follow object-ori fortran 2003 standard. follow illustr typic adapt refin library. step consist initi refin object. pass inidata object initi mesh inform retriev (elements, nodes, connectivities). inidata object defin abstract librari need implement extend user: ! myinidata s o b j e c t n t l mesh informat ion ! e x t r c t e d ca l l ref in r%i n t l z e ( inidata ) requir call object following: ! gener dimens ! number o f p o n t s processor ca l l inidata%getnpoin ( npoin ) ! number o f l o c l p o n t s processor ca l l inidata%getnpoinloc ( npoinloc ) ! number o f e lement processor ca l l inidata%getnelem ( nelem ) ! globa l number o f point ca l l inidata%getglobalnpoin ( gnpoin ) ! element c o n n e c t v t y l s t ca l l inidata%getconnect iv iti ( lem , nnode , c o n n e c t v t y ) ! l o c l g o b l map f o r s e t o f nnode node ! output s globalnumb ca l l inidata%getlocal2glob ( nnode , localnumb , globalnumb ) ! processor s e t o f nnode node s ass gned ! output s processorl s t ca l l inidata%getprocessornumb ( nnode , localnumb , p r o c e s s o r l s t ) also, coordin nodal point mesh pass refiner. tetrahedr element case order choos subel type caus lesser distortion, explain previously: ! coord conta in arrai o f coordin , necessari f o r ! sube lement type cho ic t e t r h e d r l e lement ca l l ref in r%setcoordarrai ( coord ) option set balanc flag (and forc result mesh balanced) follow manner: ! opt ional c l l f o r s e t t n g ba lanc ing f l g ca l l ref in r%set 2 1 ba lanc ing ( . f l s e . ) refin initialized, arrai contain refin criteria pass refiner, perform requir refin steps: f ( r e f n n g ) ! refinermarkel conta in f inement c r t e r f o r element ca l l ref in r%ref in ( ref inermark l ) endif instead refin step, carri load rebalanc step, extern renumb librari need done, need retriev pointglobnumb pointprocnumb arrays. available, refin follow form: d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. refficientlib: effici adapt mesh refin c81 f ( r eba l anc ing ) !a c l l e x t e r n l l b r r y f o r renumb s ! necessari ( user d e f n e d ) ca l l externallibraryrenumb ( pointglobnumb , pointprocnumb ) ! pointglobnumb , pointprocnumb contain new g l o b l ! number processor f o r p o n t s ca l l ref in r%setrebalancingnumb ( pointglobnumb , pointprocnumb ) ! commun r e b u l d f inement s t r u c t u r e ca l l ref in r%loadrebal endif refin load rebalanc step refiner, inform retriev calls, new extern flat mesh built: ! f inement s , r e t r e v e informat ion ! ref iner !new dimens ! number o f l o c l point , l o c l + gho t point , g l o b l p o n t s ca l l ref in r%getpointdimens ( newnpoinloc , newnpoin , newgnpoin ) ! number o f element , s z e o f c o n n e c t v t y arrai ca l l ref in r%getelementdimens ( newnelem , newlnodss ) ! af ter l l o c t o n o f e x t e r n l arrai , informat ion ! r e t r e v e d ref iner ! element connec t v t y l s t csr format ca l l ref in r%getlnod ( pnod , lnod ) ! local globa l processor l s t f o r new l o c l node ca l l ref in r%getlocalord ( localtoglob , p r o c e s s o r l s t ) !a l s t o f hang node ( phanginglist , lhang ingli t ) ! wi th averag ing c o e f f c e n t s ( rhanginglist ) ! csr format r e t r e v e d ref iner ca l l ref in r%gethanginglistdimens ( hang ingli ts iz ) ca l l ref in r%gethanginglist ( phanginglist , lhanginglist , rhanginglist ) !a l s t o f hang f c e s ( phanginglist , lhang ingli t ) ! csr format r e t r e v e d ref iner ca l l ref in r%gethangingfaceslist ( phangingfaceslist , lhang ingfacesli s t ) hang node list contains, node, list hang parent (lhanginglist) correspond averag coeffici (rhanginglist), store csr format. nodal arrai defin old mesh, refin allow transform (by interpol restriction) arrai new mesh: ca l l ref in r%updatevari ( ndime , coord , newcoord ) summar interact adapt refin librari user point view. addit option call exist allow pass valu boundari old mesh boundari new mesh. convenient, instance, enforc neumann boundari condit finit element analysis, includ legibl conciseness. 6. numer examples. section illustr behavior pro- pose algorithm numer examples. exampl algorithm test type linear, bilinear, trilinear elements, dimensions. 6.1. bidimension elements. numer exampl consist squar bidimension domain (0, 1) (0, 1) mesh triangular linear elements. refin process arbitrari order capabl algorithm d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. c82 joan baig camilo bayona deal multilevel jump hang faces, case concentr element top-right corner. number processor simul 25, load rebalanc cri- terion following: max (npoinlocal) nproc gnpoin tolrebalance. mesh, poisson heat transfer problem solv finit elements. heat transfer problem consist find u : rd ku = f , u = 0 d, kn u = h n , k > 0, f given forc function, h normal heat flux, denot comput domain, = = d n boundary, d n = . exampl forc term uniform valu f = 1; d compos upper, lower, left boundaries; n compos right boundary, h = 20. figur 9 show behavior method case. refinement/ unrefin steps, mesh heavili refin top-right corner rest comput domain. note process, step normal node hang node vice versa. load rebalanc act rearrang ownership node wai comput load processor approxim same. result processor deal node top-right corner. algorithm capabl deal multilevel jump hang face provid accur result temperatur field. 6.2. multipl type element singl bidimension simulation. numer exampl solv exampl present subsect 6.1, time us type elements: left half domain us triangular finit elements, right half quadrilater finit element used. exampl illustr capabl algorithm deal simultan type finit elements. figur 10 show numer results. note hang face mesh belong interfac triangular quadrilater elements. 6.3. tetrahedr hexahedr elements. numer exampl heat transfer problem solv unit cube domain. boundari condit adiabat wall lower one, temperatur fix zero. sourc term f = 1. select element refin arbitrary, refinement/unrefin step perform arriv final configuration. number processor numer exampl 6. figur 11 show behavior method case. refinement/unrefin steps, mesh heavili refin top- right quarter rest comput domain, load rebalanc algorithm act rearrang node processor comput load similar processors. algorithm capabl deal multilevel jump hang face provid accurate, smooth result temperatur field. d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. refficientlib: effici adapt mesh refin c83 fig. 9. poisson problem exampl triangular mesh. top-left: origin mesh. top-right: mesh refin steps. bottom-left: node distribut processors. bottom-right: temperatur field end simulation. note jump refin level hang face arbitrarili large. figur 12 show exampl hexahedr element 25 processors, load rebalanc criteria previou cases. three- dimension case simul multipl type elements, face element finit element shape function tetrahedr hexahedr element match interface. 6.4. applic incompress navierstok equations. numer exampl solv incompress navierstok equations, consist find u : (0, t ) rd p : (0, t ) r tu u + u u +p = f , u = 0 , u = u t > 0, tu local time deriv veloc field. rd bound domain, d = 2, 3, viscosity, f given sourc term. appropri initi condit append problem. numer solut equat finit element stabil formula- tion [9] allow deal convect term us equal interpol space veloc pressure. d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. c84 joan baig camilo bayona fig. 10. adapt simul finit element mesh type elements. top-left: origin mesh. top-right: mesh refin steps. bottom-left: node distribut processors. bottom-right: temperatur field end simulation. numer exampl deal flow cylind = 100. comput domain consist 16 8 rectangl unit-diamet cylind center (4, 4). horizont inflow veloc set 1 x = 0. slip boundari condit set y = 0 y = 8, veloc set 0 cylind surface. viscos set = 0.01, reynold number = 100 base diamet cylind inflow velocity. third-ord backward differ scheme time integr time step size t = 1 103. error estimator, zienkiewiczzhu error estim [23] veloc gradient used, result refin strategi near boundari layer region surround vortic cylinder: ek = k (uh) = k (uh h (uh)) , d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. refficientlib: effici adapt mesh refin c85 fig. 11. mesh refin tetrahedr elements. top-left: origin mesh. top-right: mesh refin steps. bottom-left: node distribut processors. bottom-right: tem- peratur field end simulation. k denot element mesh, h denot project finit element space, denot project space orthogon finit element space. figur 13 show result mesh evolut obtain example. note refin process, normal node hang node vice versa step. 6.5. applic nonsmooth solution. present nonsmooth solut exampl steadi stoke problem, consist find u : (0, t ) rd p : (0, t ) r u +p = f , u = 0 , u = u , r2 two-dimension bound domain, viscosity, f given sourc term. diverg free nonsmooth manufactur solut considered: d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. c86 joan baig camilo bayona fig. 12. mesh refin hexahedr elements. top-left: origin mesh. top-right: mesh refin steps. bottom-left: node distribut processors. bottom-right: tem- peratur field end simulation. u (r, ) = r [ co () () + (1 + ) sin () () sin () () (1 + ) co () () ] , p (r, ) = r(1) (1 + ) 2 () + () 1 , (r, ) = sin ((1 + )) co () 1 + co ((1 + )) + sin (( 1)) co () 1 + co (( 1)) . taken = 3/2 0.5444837, approxima- d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. refficientlib: effici adapt mesh refin c87 fig. 13. adapt refin finit element solut flow past cylinder. contour result veloc pressur fields, refin mesh details, present separ configur wake oscillation. tion root nonlinear equat sin2 () 2 sin2 () 2 = 0. depart linear element triangular mesh refin zienkiewiczzhu error estim refin criteria explain previou ex- ample. figur 14 show obtain veloc pressur solutions. origin refin mesh refin step displayed. re- finement level develop refin mesh. mesh refin deal d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. c88 joan baig camilo bayona fig. 14. adapt refin finit element solut stoke problem, nonsmooth solution. contour result veloc (top-left) pressur (top-right) fields, origin (bottom- left) refin (bottom-right) meshes. singular appear corner provid accur solut capabl better repres pressur field close singularity. 6.6. applic free surfac flows. numer exampl consist simul water flow deck ship follow impact result wave obstacle. well-known benchmark free surfac problem studi experiment maritim research institut netherland (marin). experiment data avail [18]. set problem following. larg tank open roof considered. tank, gate isol volum water lai rest constant free surfac height. tank prismat obstacl repres contain deck ship. obstacl static, fluid-structur interact effect considered. experi start gate quickli open d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. refficientlib: effici adapt mesh refin c89 fig. 15. posit free surfac comput mesh instant simula- tion green water flow case. (the durat gate-open process consid zero) result water wave impact obstacl wall tank. pressur time histori point surfac obstacl measur compar experiment results. initi mesh compos 3756 linear tetrahedra element used. time step set 0.01 s (seconds) total 6 s simulated. finit element mesh success adapted, mesh refin heavili local free surface, lead import save comput effort. figur 15 posit free surfac time instant shown, mesh time steps. 6.7. scalabl tests. section test scalabl propos refin method larg number processor used. consid cases. case, solv adapt refin case problem balanced, load rebalanc required. second case, test algorithm d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. c90 joan baig camilo bayona 0 5 10 15 20 25 0 500 1000 1500 2000 s e c o n d s number processor 0.4 0.6 0.8 1 1.2 1.4 1.6 0 500 1000 1500 2000 s e c o n d s number processor fig. 16. uniform refin weak scalabl result 1849 processors. notat element type follows: triangles(4), squar (), tetrahedra(n), hexahedra(). left: case depart initi point processor configur (100 bidimension element 8 three-dimension elements) perform 6 level uniform refinement. thereafter, includ uniform unrefinement/refin step refin level. type run perform order abl measur overal refin perform time steps, calcul marenostrum supercomputer. right: case depart initi point processor configur (90,000 bidimension element 270,000 three-dimension elements) perform singl level uniform refinement. calcul case beskow supercomputer. case load rebalanc requir step refin process. step refin element contain insid domain, follow uniform refin criterion refin criterion aggress forc load rebalancing. weak scalabl test run 1849 processor bidimen- sional elements, 1728 processor three-dimension elements. scalabl case limit 2000 million total element largest mesh creat refin level, current implement us 4 byte integ nodal element counters. test present subsect run marenostrum supercomput barcelona supercomput center, beskow supercomput kth, sweden. marenostrum supercomput equip intel sandybridge-ep e5-2670 core 2.6 ghz (3056 comput nodes) 103.5 tb main memory. beskow supercomput crai xc40 base intel xeon e5-2698v3 core 2.3 ghz (1676 comput nodes) 104.7 tb main memory. weak scalabl test correspond uniform refin problem. depart structur uniform mesh initi number element point processor, success refin it. time step refin element entir spatial domain. cpu runtim invest refin procedur present figur 16. object weak scalabl test measur commun processors. commun need load balancing, measur time refin procedure. result increas runtim 1 100 processors. 100 processor flat tendenc observed. scale result good bidimension three-dimension cases, ensur correct behavior adapt refin d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. refficientlib: effici adapt mesh refin c91 0 20 40 60 80 100 64 256 1024 1849 p e r c e n t g e o f r u n t m e number processor 0 20 40 60 80 100 64 256 1024 1849 p e r c e n t g e o f r u n t m e number processor 0 20 40 60 80 100 27 216 1000 1728 p e r c e n t g e o f r u n t m e number processor 0 20 40 60 80 100 27 216 1000 1728 p e r c e n t g e o f r u n t m e number processor fig. 17. runtim fraction result uniform refin weak scale test 1849 pro- cessor beskow supercomputer. triangl (top-left), squar (top-right), tetrahedra (bottom- left), hexahedra (bottom-right) element type case evaluated. descript case given figur 16. perform singl level uniform refin solv stationari heat transfer problem result refin mesh. refin procedur runtim fraction plot solid fill, linear runtim fraction plot pattern fill. address fraction time requir singl refin procedur comparison time spent linear solver order solv refin mesh linear system. compar result best runtim linear solvers, given biconjug gradient method implement petsc parallel solver librari [1], ml precondit packag implement trilino librari [10]. algorithm. runtim fraction refin procedur respect linear solut present figur 17 singl time step. result runtim domin linear solution, runtim fraction refin procedur decreas number processors, ensur good behavior larg scale computing. second weak scalabl test intend evalu overal perform load rebalanc necessary. case depart structur uniform mesh refin success follow refin criteria. step re- fine element contain insid domain r = (1 12i , 1)(1 1 2i , 1)(0, 1), denot step number case. criterion defin spatial distri- bution partial refin element domain. figur 18 show runtim d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. c92 joan baig camilo bayona 0 10 20 30 40 50 60 70 80 0 500 1000 1500 2000 s e c o n d s number processor 1 2 3 4 5 6 7 8 0 500 1000 1500 2000 s e c o n d s number processor fig. 18. load balanc refin weak scalabl result 1849 processors. notat element type follows: triangl (4), squar (), tetrahedra (n), hexahedra (). left: case depart initi point processor configur (4900 bidimension element 8 three-dimension elements) perform 15 level load rebalanc refinement. run calcul marenostrum supercomputer. right: case depart initi point processor configur (90,000 bidimension element 270,000 three-dimension elements) perform singl level forc load rebalanc refinement. calcul case beskow supercomputer. requir refin load balanc procedures. interprocessor com- munic case refin step load rebalanc procedure. asymptot tendenc reach bidimen- sional three-dimension element number processor increases. three-dimension element weak scale result good rang 1000 pro- cessors. runtim fraction spent refin load balanc procedur respect linear solut present figur 19. case refin load balanc comput cost small moder respect linear solve. linear solv test one-degree-of- freedom heat transfer problem. case incompress navierstok prob- lem, nonlinear larger number degre freedom node increas consider cost solv linear system, refin procedur cost remain same, lead smaller runtim fraction refin step. therefore, conclud implement propos algorithm ef- ficient respect cost solv linear system adapt refin meshes, algorithm suitabl larg scale problem high-perform comput environments. 7. conclusions. paper novel parallel, hierarchical, load rebal- anc algorithm adapt mesh refin (amr) coarsen unstructur bidimension three-dimension mesh presented. main featur propos algorithm suitabl nodal base partit distribut memori framework capabl success refin unrefin mesh effici manner cluster thousand processors. differ type mesh dealt algorithm, includ triangular, quadrilateral, tetrahedral, hexahedr elements, mesh type elements. d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. refficientlib: effici adapt mesh refin c93 0 20 40 60 80 100 64 256 1024 1849 p e r c e n t g e o f r u n t m e number processor 0 20 40 60 80 100 64 256 1024 1849 p e r c e n t g e o f r u n t m e number processor 0 20 40 60 80 100 27 216 1000 1728 p e r c e n t g e o f r u n t m e number processor 0 20 40 60 80 100 27 216 1000 1728 p e r c e n t g e o f r u n t m e number processor fig. 19. runtim fraction result load rebalanc refin weak scale test 1849 processor beskow supercomputer. triangl (top-left), squar (top-right), tetrahedra (bottom-left), hexahedra (bottom-right). descript case given figur 18. perform singl level forc load rebalanc refin solv stationari heat transfer problem result refin mesh. linear solver set biconjug gradient ml preconditioner. refin runtim fraction plot solid fill, load balanc runtim fraction plot coars pattern fill, linear runtim fraction plot fine pattern fill. memori requir algorithm reduc local level, inform correspond mesh current processor subdomain need store locally. result refin mesh nonconform hang nodes, balanc restrict need enforc adja- cent elements, allow jump multipl refin level neighbor elements. load rebalanc scheme present independ re- balancing/renumb strategy, chosen user. graph par- tition scheme space-fil method (or renumb strategi load rebalancing) propos algorithm. numer test present illustr perform propos algorithm. set test deal simul driven problem poisson heat transfer problem incompress navierstok equat d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. c94 joan baig camilo bayona adapt meshes, expect behavior refin algorithm obtained. second set test studi scalabl algorithm 2000 cpu cluster good weak scalabl result obtain mesh 2000 million elements. also, runtim fraction refin process reduc compar runtim solv linear system equat gener meshes, ensur suitabl propos algorithm larg comput physic problem high-perform comput environments. propos algorithm pack refficientlib fortran 2003 librari user interfac presented. allow easi integr (with 10 call adapt refin library) propos algorithm exist comput physic codes. algorithm current deal h-refinement; extens algorithm hp-refin matter futur work. acknowledgments. simul marenostrum supercom- puter barcelona supercomput center centro nacion supercomputacion (the spanish nation supercomput center) beskow supercomput royal institut technolog (kth), sweden. acknowl- edg prace award access resourc marenostrum base spain barcelona. support red espanola supercomputacion (res) european prace network acknowledged. refer [1] s. abhyankar, m. f. adams, s. balay, j. brown, l. dalcin, t. isaac, m. g. knepley, d. may, k. rupp, j. sarich, b. f. smith, s. zampini, h. zhang, h. zhang, petsc (portable, extens toolkit scientif computation), version 3.7, 2016, //www.mcs.anl.gov/petsc. [2] s. badia j. baiges, adapt finit element simul incompress flow hy- brid continuous-discontinu galerkin formulations, siam j. sci. comput., 35 (2013), pp. a491a516, [3] w. bangerth, c. burstedde, t. heister, m. kronbichler, algorithm data struc- ture massiv parallel gener adapt finit element codes, acm trans. math. soft- ware, 38 (2011), 14. [4] e. g. boman, u. v. catalyurek, c. chevalier, k. d. devine, zoltan isor- ropia parallel toolkit combinatori scientif computing: partitioning, ordering, coloring, sci. program., 20 (2012), pp. 129150. [5] c. burstedde, o. ghattas, m. gurnis, t. isaac, g. stadler, t. warburton, l. wilcox, extreme-scal amr, proceed 2010 acm/iee intern con- ferenc high perform computing, networking, storag analysis, ieee com- puter societi press, piscataway, nj, 2010, pp. 112. [6] c. burstedde, l. c. wilcox, o. ghattas, p4est: scalabl algorithm parallel adap- tive mesh refin forest octrees, siam j. sci. comput., 33 (2011), pp. 11031133, [7] p. m. campbell, k. d. devine, j. e. flaherty, l. g. gervasio, j. d. teresco, dynam octre load balanc space-fil curves, technic report cs-03-01, depart science, william college, williamstown, ma, 2003. [8] b. cockburn c.-w. shu, rungekutta discontinu galerkin method conser- vation law v: multidimension systems, j. comput. phys., 141 (1998), pp. 199224. [9] r. codina, stabil finit element method gener stationari incompress flows, comput. method appl. mech. engrg., 190 (2001), pp. 26812706. [10] m. heroux, r. bartlett, v. h. r. hoekstra, j. hu, t. kolda, r. lehoucq, k. long, r. pawlowski, e. phipps, a. salinger, h. thornquist, r. tuminaro, j. willenbring, a. williams, overview trilinos, technic report sand2003-2927, sandia nation laboratories, albuquerque, nm; livermore, ca, 2003. [11] t. isaac, c. burstedde, o. ghattas, low-cost parallel algorithm 2 : 1 octre balance, proceed ieee 26th intern parallel & distribut process symposium, ieee societi press, piscataway, nj, 2012, pp. 426437. d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp copyright siam. unauthor reproduct articl prohibited. refficientlib: effici adapt mesh refin c95 [12] n. jansson, j. hoffman, j. jansson, framework massiv parallel adapt finit element comput fluid dynam tetrahedr meshes, siam j. sci. comput., 34 (2012), pp. c24c41, [13] g. karypi v. kumar, fast high qualiti multilevel scheme partit ir- regular graphs, siam j. sci. comput. 20 (1998), pp. 359392, s1064827595287997. [14] b. s. kirk, j. w. peterson, r. h. stogner, g. f. carey, libmesh: c++ librari parallel adapt mesh refinement/coarsen simulations, engin computers, 22 (2006), pp. 237254. [15] a. langer, j. lifflander, p. miller, k.-c. pan, l. v. kale, p. ricker, scalabl algo- rithm distributed-memori adapt mesh refinement, proceed ieee 24th intern symposium architectur high perform comput (sbac-pad), ieee societi press, piscataway, nj, 2012, pp. 100107. [16] s. popinet, gerris: tree-bas adapt solver incompress euler equat complex geometries, j. comput. phys., 190 (2003), pp. 572600. [17] r. s. sampath g. biros, parallel geometr multigrid method finit element octre meshes, siam j. sci. comput., 32 (2010), pp. 13611392, 090747774. [18] s.e.r.i. community, [19] h. sundar, r. s. sampath, g. biros, bottom-up construct 2:1 balanc refin linear octre parallel, siam j. sci. comput., 30 (2008), pp. 26752708, org/10.1137/070681727. [20] t. tu d. ohallaron, balanc refin massiv linear octrees, technic report cmu-cs-04-129, school science, carnegi mellon university, pittsburgh, pa, 2004. [21] t. tu, d. r. ohallaron, o. ghattas, scalabl parallel octre mesh terascal applications, proceed acm/iee 2005 confer supercomputing, ieee societi press, piscataway, nj, 2005, p. 4. [22] t. tu, d. r. ohallaron, j. c. lopez, etree: database-ori method gener larg octre meshes, engin computers, 20 (2004), pp. 117128. [23] o. c. zienkiewicz j. z. zhu, simpl error estim adapt procedur prac- tical engin analysis, int. j. numer. method engrg., 24 (1987), pp. 337357. d ow nl oa d 06 /1 6/ 17 t o 5. 19 6. 89 .2 25 . r ed tr ib ut io n su bj ec t s ia m l ic en se o r py ri gh t; s ee h tt p: // w w w .s ia m .o rg /j ou rn al s/ oj sa .p hp introduct distribut refin structur mesh partit distribut data structur globalelementidentifi data structur inverseglobalpointnumberinglist initi refin step amend element refin classif local refin parallel number hang node export extern mesh load rebalanc rebal renumb rebuild refin structur extern call refficientlib librari numer exampl bidimension element multipl type element singl bidimension simul tetrahedr hexahedr element applic incompress navierstok equat applic nonsmooth solut applic free surfac flow scalabl test conclus refer
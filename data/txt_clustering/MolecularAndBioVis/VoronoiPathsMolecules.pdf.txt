





































untitled


Voronoi-Based Extraction and Visualization of Molecular Paths
Norbert Lindow, Daniel Baum, and Hans-Christian Hege, Member, IEEE

Fig. 1. Mechanosensitive channel (PDB: 2OAU). Left: Ball-and-stick representation (yellow), potential molecular paths (blue), and
extension surface (red) of the most important paths. Middle: Van der Waals surface of the molecule with screen space ambient
occlusion and path illumination. Right: Solvent excluded surface clipped by the extension surface of the red paths.

Abstract—Visual analysis is widely used to study the behavior of molecules. Of particular interest are the analysis of molecular
interactions and the investigation of binding sites. For large molecules, however, it is difficult to detect possible binding sites and
paths leading to these sites by pure visual inspection. In this paper, we present new methods for the computation and visualization of
potential molecular paths. Using a novel filtering method, we extract the significant paths from the Voronoi diagram of spheres. For
the interactive visualization of molecules and their paths, we present several methods using deferred shading and other state-of-the-
art techniques. To allow for a fast overview of reachable regions of the molecule, we illuminate the molecular surface using a large
number of light sources placed on the extracted paths. We also provide a method to compute the extension surface of selected paths
and visualize it using the skin surface. Furthermore, we use the extension surface to clip the molecule to allow easy visual tracking of
even deeply buried paths. The methods are applied to several proteins to demonstrate their usefulness.

Index Terms—Molecular visualization, data filtering, geometry-based techniques, view-dependent visualization.

1 INTRODUCTION

Understanding molecular interactions is the key to many open ques-
tions in biochemistry, molecular biology and pharmaceutics. This is
because molecular interactions are the driving forces for many bio-
chemical processes taking place in all kinds of organisms, from the
most simple to highly developed ones. Before interactions can take
place, however, the interacting molecules must come close enough to
each other. For example, before a ligand can bind to a protein, the
ligand must reach the binding site of the protein. Hence, besides an-
swering the question whether a ligand can bind to the protein’s binding
site, we also need to know, whether the ligand can reach the binding
site, and if, what the possible paths are.

Over the past two decades, several methods to explore and visualize
molecular paths have been proposed. Most of them [8, 38, 39, 45, 48]
are restricted to a small subset of paths. Others are able to detect all
channels in a molecule but do not find cavities [11]. Further meth-
ods [19, 24, 28, 40, 47] do not compute path descriptions but only the
surface of accessible areas.

In this paper, we address the problem of computing and visualiz-
ing paths to all regions of a molecule. The computation of these paths
is particularly interesting for molecules like nanotransporters, whose
design is becoming more and more important [27]. Nanotransporters
are often very complex and have many binding sites. Identification of
these binding sites via molecular dynamics simulations is too expen-

• Norbert Lindow, Daniel Baum, and Hans-Christian Hege are with Zuse
Institute Berlin, E-mail: {norbert.lindow, baum, hege}@zib.de.

Manuscript received 31 March 2011; accepted 1 August 2011; posted online
23 October 2011; mailed on 14 October 2011.
For information on obtaining reprints of this article, please send
email to: tvcg@computer.org.

sive. Hence, there is a need to restrict the search space. Here, the paths
computed with our method can provide guidance for the computation
of molecular dynamics simulations.

We compute the paths from the Voronoi diagram of spheres which
already contains all paths we are interested in. For the calculation of
the Voronoi diagram of spheres, we present improvements to speed up
the algorithm for molecular data. To extract the paths, we apply a fast
novel method to filter the Voronoi diagram. The filter needs only few
parameters and is easy to implement, since it is based on depth first
search in the graph built from the Voronoi diagram. The paths that re-
main after filtering provide a good overview of all accessible areas of
the molecule. We visualize the molecule and its paths using deferred
shading and other state-of-the-art methods like ray-casting and screen
space ambient occlusion. Furthermore, by placing light sources along
the paths, we draw the attention of the user to the cavities and chan-
nels. All visualizations run at interactive speed. We also support the
selection of single paths by the user to explore them more thoroughly.
For the selected paths, we compute their extension surface and visual-
ize it using the skin surface. This has several advantages over previ-
ous methods. Moreover, to allow easy tracking of even deeply buried
paths, we clip the molecule using their extension surface.

2 RELATED WORK

Our geometry-based path detection relies on the computation of
Voronoi diagrams. Voronoi diagrams were defined by the Ukrainian
mathematician G. Voronoi in 1908. A survey on the basics of the dia-
grams, their variations and algorithms is given, for example, by Okabe
et al. [36] or Aurenhammer [3]. In 2005, Kim et al. [21] presented the
first algorithm to compute the Voronoi diagram of spheres in three-
dimensional space. One year later, they accelerated this algorithm by
reducing the search space [10]. Medvedev et al. [35] presented a sim-
ilar algorithm in the same year. In 2007, Man̆ák et al. [33] published
further improvements for the techniques of [10, 21] by the use of the

2025

        1077-2626/11/$26.00 © 2011 IEEE       Published by the IEEE Computer Society

IEEE TRANSACTIONS ON VISUALIZATION AND COMPUTER GRAPHICS, VOL. 17, NO. 12, DECEMBER 2011



Delaunay complex and an iterative reduction of the search space.

The detection of molecular paths and cavities is a large research
area with many different approaches. Because of the large number
of publications in this field, we will mention only the most signifi-
cant works dealing with geometry-based extraction and identification
of such structures.

The first group of tools creates surfaces or volumes for cavi-
ties and channels by filling them with geometric structures. While
SURFNET [28], HOLLOW [19] and 3V [47] use probe spheres of
variable size, VOIDOO [24] takes water molecules and Exner et
al. [16] as well as Raunest and Kandt [40] take voxels, where their
tool dxTuber is the first to deal with dynamic proteins. The recently
presented work by Krone et al. [26] improves handling of dynamic
proteins with interactive detection and exploration of selected cavities.
They integrated their work into MegaMol. All these tools provide a
good visual representation of the interior area, but the result is always
represented by surfaces or volumes that do not contain detailed path
information like branching points, etc. This makes it difficult to detect
alternative paths or to extract and analyze specific paths.

The second group of tools detects channels through proteins. There
are several different approaches and most of them require a user-
defined starting position. One of the tools is HOLE [45], which uses
a simulated annealing technique to maximize the radius of spheres
without overlapping the van der Waals surfaces of the atoms. Petrěk et
al. [39] presented a grid based path search named CAVER. The weight
of each grid cell depends on the distance to the molecule, which allows
using the Dijkstra shortest path algorithm for an easy path detection.
One year later, Petrěk et al. [38] enhanced their algorithm by using
a classical Voronoi diagram instead of a grid. They called the new
tool MOLE. A similar approach based on the idea of Voronoi dia-
grams of spheres, but using the dual Delaunay complex of the classi-
cal Voronoi diagram, was done by Medek et al. [34] in the same year.
In 2008, Yaffe et al. [48] presented MolAxis which provides further
improvements including a better approximation of the different atom
radii. PoreWalker [8] was the first program that computed the greatest
channel in a protein without a user-defined starting position. However,
all of these tools are restricted to the computation of only one channel
or a fixed number of paths for a single starting position. The CHUN-
NEL [11] tool addresses this problem and detects all channels in a
protein by analyzing the topology of the molecular solvent excluded
surface. However, the algorithm does not detect cavities like molec-
ular pockets and the computation takes very long, even for molecules
with only a few thousand atoms.

The last group comprises all tools and publications that do not di-
rectly belong to any of the other two groups. In contrast to CHUN-
NEL, CAST [30] detects all molecular pockets instead of the channels.
This tool relies on the alpha shape theory [15]. A similar approach
was used by Maeda et al. [32] to evaluate protein-protein interfaces.
Roll [49] is a program that also detects pockets based on the compar-
ison of molecular surfaces with different probe radii. Molecular path
planning employing rapidly-exploring random trees (RRTs) [29] was
done by Cortes et al. [13, 12]. This technique allows one to detect
paths depending on the geometry and dynamic of a given substrate,
but the algorithm does not compute all paths of a protein. Finally, Ba-
jaj et al. [4] proposed an algorithm to detect and characterize cavities
in molecular structures based on the topological research of level sets.

Nearly all of the mentioned path detection tools visualize their re-
sults. In most cases, they approximate the surface of the channels and
cavities. These surfaces are rendered in combination with standard
molecule visualization. State-of-the-art rendering of smooth molecu-
lar surfaces was presented by Chavent et al. [9], Krone et al. [25] and
Lindow et al. [31]. A new volume-based approach for rendering dy-
namic molecular surfaces was presented by Krone et al. [26]; it allows
clipping of the molecule with a plane. Tarini et al. [46] described an
algorithm for real-time ambient occlusion of the van der Waals sur-
face and the ball-and-stick representation. Another approach based on
ambient occlusion was presented by Borland [7] for rendering molec-
ular cavities. Bidmon et al. [6] developed an algorithm for the visual
clustering of molecular path lines. Apart from molecular visualiza-

tion, there exist many other approaches to render paths with their sur-
rounding geometry. As an example, the flow visualization technique
of Jones et al. [20] shall be mentioned.

3 VORONOI DIAGRAM OF SPHERES
In this paper, we assume that a molecule is given by its n atoms with
positions pi ∈ R3 and van der Waals radii ri ∈ R. Thus, we consider a
molecule as a set of spheres.

From this description of a molecule, we compute the potential
molecular paths in two main steps. First, we compute the Voronoi
diagram of spheres from the van der Waals spheres. The Voronoi di-
agram of spheres represents a complete description of the topological
structure of the distance transform d(·) of the molecule, where

d(p) := min{‖p− pi‖− ri | 1≤ i≤ n}. (1)
The paths we are looking for are a subset of this topological structure.
Hence, the Voronoi diagram of spheres already contains all paths that
are of interest to us. Thus, we only need to filter the Voronoi diagram
in a second step. The computation of the Voronoi diagram of spheres
is described in this section, while the filtering is addressed in Sect. 4.

Note that from now on, whenever we use the term Voronoi diagram
we refer to the Voronoi diagram of spheres.

3.1 Definition
A three-dimensional Voronoi diagram consists of Voronoi regions,
facets, edges, and vertices. A Voronoi region of an atom is the set
of all points closest to the corresponding sphere, that is,

Vi =
{

p |‖p− pi‖− ri ≤
∥∥p− p j∥∥− r j, i �= j} .

For the definition of the remaining Voronoi structure, there are two
limitations. First, there must not exist a point with the same distance to
more than four atom spheres, because this yields a degenerate Voronoi
diagram. In practice, we avoid such situations by adding a very small
random offset to all atom positions. Second, no sphere may lie com-
pletely inside another sphere, which should not be the case for van der
Waals spheres of a molecule.

A Voronoi facet is the surface between two atoms given by the
intersection of their Voronoi regions. The analytical description of
a Voronoi facet is a piece of a two-sheeted hyperboloid bounded by
curves, the Voronoi edges.

A Voronoi edge is the intersection of three Voronoi regions. It
can be described as a part of a planar rational quadratic Bézier curve.
These curves are symmetric w.r.t. the plane given by the three spheres
of the regions and can be closed or unclosed. A closed curve will be
created by a small sphere lying between two great spheres. In a spe-
cial case, the Voronoi edge is equal to the complete closed curve. The
algorithm that we describe next will not detect such edges. All other
Voronoi edges are bounded by at least one Voronoi vertex.

Finally, a Voronoi vertex lies at the intersection of four Voronoi
regions. Each vertex describes the center of an empty sphere tangent
to the four spheres given by the regions. A two-dimensional Voronoi
diagram of circles is illustrated in Fig. 4.

3.2 Computation
3.2.1 Computation of a tangent sphere of four spheres
The computation of the Voronoi diagram requires the calculation of
tangent spheres for sets of four atoms i, j,k, l. Here, we summarize
the method of Gavrilova et al. [17]. Assume without loss of generality
that atom l has the smallest radius. We move the atoms such that l lies
at the origin. Then we shrink the four radii by the radius of atom l.
As result, we get the following equation system for the tangent sphere
with position p̃ and radius r̃ of the transformed atoms.

( p̃− p̃i)2 = (r̃+ r̃i)2, where p̃i = pi− pl and r̃i = ri− rl
(p̃− p̃ j)2 = (r̃+ r̃ j)2, where p̃ j = p j− pl and r̃ j = r j− rl
( p̃− p̃k)2 = (r̃+ r̃k)2, where p̃k = pk− pl and r̃k = rk− rl

p̃2 = r̃2

2026 IEEE TRANSACTIONS ON VISUALIZATION AND COMPUTER GRAPHICS, VOL. 17, NO. 12, DECEMBER 2011



ce αmax

se

Fig. 2. Illustration of an edge tracing step in 2D. The gate consists of
the blue spheres with the start vertex depicted by the red sphere. The
center of the green sphere is ge and the end vertex is drawn as dotted
red sphere. The maximal angular distance is αmax.

The first three equations become linear by subtracting the fourth.
Now, we solve the linear system with r as parameter and apply the
solution to the last equation yielding a quadratic equation in r. The
system can have none, one, two or infinitely many solutions. For
Voronoi diagrams, we only consider the empty tangent spheres. We
get the radii of the tangent spheres by applying the inverse translation
and subtracting the radius of l.

3.2.2 The Edge Tracing Algorithm

To compute the Voronoi diagram of spheres, Kim et al. [21] pre-
sented the edge tracing algorithm. This algorithm starts with an initial
Voronoi vertex. From this Voronoi vertex, Voronoi edges are traced
until no further edge can be found. To find the initial Voronoi ver-
tex, Kim et al. [21] and Medvedev et al. [35] propose two different
methods, which we will not explain here.

Consider a correct Voronoi start vertex tangent to four atom
spheres. This vertex creates four Voronoi edges, one edge for each
atom triple. Kim et al. [21] call these triples gates and we adopt this
term. Each gate holds the corresponding start vertex and is added to a
stack. The algorithm then starts tracing the edges as follows:

1: while stack.hasElements() do
2: gate← stack.pop();
3: vertex← computeEndVertex(gate);
4: if vertexIsNew(vertex) then
5: graph.addVertex(vertex);
6: stack.addGates(vertex, gate);
7: end if
8: graph.addEdge(gate, vertex);
9: end while

The algorithm takes a gate from the stack and computes the end vertex.
If the end vertex is equal to an existing vertex in the graph, we only
create the edge. Otherwise, we add the vertex to the graph and push
the remaining three gates to the stack.

The computation of the end vertex is the most expensive part of the
algorithm. We have to find the fourth atom sphere for the three given
gate atoms, so that the tangent sphere of these atoms is empty and clos-
est to the start vertex. All n−3 remaining atoms have to be considered.
Note that the fourth atom of the start vertex could also be the fourth
atom of the end vertex. With a naive approach, we get a time complex-
ity of O(n2), because we have to compute the tangent spheres and test
them for emptiness. But Kim et al. [21] found that the tangent sphere
closest to the start vertex w.r.t. an angular directed distance is equal to
the end vertex. So the emptiness test is not necessary, which reduces
the complexity to O(n). We describe the computation of the edge di-

d

Fig. 3. The left image shows the expansion of the search space by grid
rings, starting with the red grid cell. On the right side, one can see the
break condition d > rmax for the blue gate with green start vertex and red
current end vertex.

rection in detail, because Kim et al. [21] give only a coarse description
and the technique presented by Medvedev et al. [35] works only for
unbounded data with a relatively regular atom distribution as present
in liquids or gases. One method to detect the direction of an edge is
to shrink the sphere of the start vertex. Consider the set of all tangent
spheres of a gate (see Fig. 2). The start and end vertices of an edge
are elements of this set. The idea is to move the start vertex to the end
vertex by changing the radius such that the current sphere is empty and
tangent to the gate. If we move the start vertex into the wrong direc-
tion, the sphere will intersect the fourth atom. So we define a direction
by shrinking the start vertex and testing whether it is still empty. To
realize the shrinking, we calculate the position of a sphere with given
radius tangent to the three gate spheres. This is done similarly to the
computation of a tangent sphere of four spheres (see Sect. 3.2.1). We
use the same transformation for the three gate spheres. This yields a
system of two linear and one quadratic equations. In the regular case,
we obtain two spheres. The sphere closer to the start vertex needs to be
tested for intersection with the fourth atom. Remember that the edge
lies in a plane, which we call edge plane (proofed by Kim et al. [21]).
The direction is given by the normal of the edge plane. The initial
normal ne of the position se of a start vertex is defined as

ne = (se− ce)× (ge− ce)
where ce is a point in the edge plane and ge is the intersection of the
edge curve with the plane defined by the centers of the three gate
spheres (see Fig. 2). One can compute ge by transforming the gate
spheres into the two-dimensional plane. Then one computes the empty
tangent circles of three given circles. This is similar to what we de-
scribed above in one dimension lower (see Sect. 3.2.1). The inverse
transformation returns the resulting position of ge. We obtain one so-
lution for an unclosed edge curve and two solutions for a closed curve,
where we take the position of the smaller circle. The point ce is nec-
essary for the definition of a distance between two points of an edge.
The distance de of two edge points e1 and e2 is defined by

de(e1,e2) =

{
∠(e1− ce,e2− ce) if 〈e1× e2,ne〉> 0
2π−∠(e1− ce,e2− ce), else .

For an unclosed edge curve, we choose ce to lie on the symmetry axis
of the curve with ce �= ge, and for a closed curve, we select the mid-
point of the two solutions for ge. If the shrunken start vertex intersects
the fourth atom, we have to invert ne. Now we have defined a direction
of the edge depending on a point ce and the edge plane normal ne.

The nearest sphere is defined by the smallest angular distance de
from the start vertex to the position of the sphere. Note that the angle
takes values between 0 and 2π and that there exists a maximum angle
smaller than 2π for unclosed edge curves. The maximum angle is the
directed angle between se− ce and the vector on the symmetry axis
that does not intersect the curve, see Fig. 2. All vertices with a greater
distance are invalid, because there is no possibility to reach them by

2027LINDOW ET AL: VORONOI-BASED EXTRACTION AND VISUALIZATION OF MOLECULAR PATHS



moving the start vertex into the correct direction. In case that none of
the n−3 atoms creates a valid tangent sphere, the edge goes to infinity.
Therefore, we compute a representative vertex with a great radius and
mark it as infinity vertex. We also implemented the techniques by
Cho et al. [10] to further reduce the costs. Nevertheless, the overall
complexity of the algorithm is O(n ·e), where e is the number of edges.
3.2.3 Further improvements for faster calculation
To further reduce the search space, we use a three-dimensional grid
as spatial data structure. An atom belongs to a grid cell if its center
lies inside the cell. For molecules, it is a good choice to set the max-
imal number of grid cells equal to the number of atoms. The grid is
designed in the following way. First one computes the axis aligned
bounding box of the atoms. Then, the cell size and the real number of
grid cells is calculated such that the cells become similar to a cube.

The grid allows a fast detection of the end vertex without touching
all n−3 atoms. This is done by looping over rings of grid cells. In the
first loop, we run over all atoms in the cell of the start vertex. The sec-
ond loop tests all atoms of all grid cells that touch the cell of the first
loop, and so on (see Fig 3). When we reach a state at which the dis-
tance of the current end vertex to the nearest remaining potential atom
with greatest possible radius rmax is greater than the sum of their radii,
we have found the end vertex and can stop the search. We approximate
this for the i’th loop by

d = cr−
∥∥cg− ep∥∥− er > rmax,

where cg is the center of the cell of the first loop and cr = (i−0.5)cmin
with cmin being the smallest cell dimension. The vertex position is ep
and its radius is er (see Fig. 3). The grid reduces the complexity to
O(1) in regions with a high atom density, but does not speed up the
vertex detection at boundaries.

To further improve the runtime, we developed a parallel version of
the algorithm. For this, we need two stacks of gates, an active and
an inactive one. The algorithm computes all end vertices of the gates
of the active stack in parallel. Then, we sequentially pop the vertices
of the active stack. We test whether the vertex already exists in the
graph. If not, we add the vertex and the new gates to the inactive
stack. In the last step, we switch the active and inactive stacks and
restart the procedure until the active stack is empty. Note that the
most expensive part of the algorithm is done in parallel.

3.2.4 Boundary Handling
The Voronoi diagram contains many edges outside the domain of the
molecule and a lot of them are infinitely long. These edges are not ele-
ments of molecular paths and create visual clutter around the molecule.
To remove them, we first cut the Voronoi diagram with the axis aligned
bounding box. Of course, this does not suffice for molecules whose
shapes are not box-like.

So in the second step, we remove the remaining paths by applying a
simple technique that is also used in computer graphics for the approx-
imation of ambient light in a point. For this, at each vertex, we cast a
set of rays in all directions. The more rays hit the molecule the more
likely it is that the vertex resides inside the molecule. For vertices in-
side cavities and channels, many rays will intersect the molecule. One
interpretation for this method is, that vertices with sparse ambient illu-
mination are inside or near the molecule. We remove all vertices, for
which the hit ratio, that is the ratio between the number of rays hitting
the molecule and the overall number of rays, is smaller than a given
threshold. Note that a value of 0.5 approximately cuts the vertices
outside the convex hull of the molecule and that we can parallelize the
whole computation. Fig. 6 shows a result of our boundary handling.

3.3 Topological Structure
The Voronoi diagram of the van der Waals spheres describes the com-
plete topology of the distance transform d(·) of the molecule. We
adapt the definition of the critical points of d(·) from Siersma [43].
For this, we need the dual structure of the Voronoi diagram of spheres,

Fig. 4. The left image illustrates a two-dimensional Voronoi diagram of
circles. Each vertex corresponds to an empty circle (dotted). The right
side shows our corresponding directed topology graph with blue minima,
red maxima and yellow regular vertices.

called quasi-triangulation [22, 23], which is the analogon of a Delau-
nay complex for a classical Voronoi diagram. We distinguish four
different types of critical points:

• Minima. The minima lie at the centers of the atoms.
• Index 1 saddles. An index 1 saddle lies in the Voronoi facet at

the intersection point with its dual quasi-triangulation edge.

• Index 2 saddles. An index 2 saddle lies on a Voronoi edge at the
intersection point with its dual quasi-triangulation facet.

• Maxima. The maxima are the Voronoi vertices that lie inside
their dual quasi-triangulation region.

Note that the critical points do not have a one-to-one correspondence
to the Voronoi structures, that is, there does not exist a critical point on
every Voronoi facet, edge, or vertex. This is only guaranteed for the
Voronoi region, which always contains a minimum.

4 PATH COMPUTATION
4.1 Topology Graph Construction
The Voronoi edges and vertices contain all points that locally are fur-
thest away from the atoms of the molecule. These are exactly the
points we are interested in. Therefore, in the following, we concentrate
on the vertices and edges and ignore the Voronoi facets and regions.
From these topological structures, we build a topology graph that we
simplify to obtain the most significant potential molecular paths. Now
we describe the construction of the topology graph from the Voronoi
diagram. The directed topology graph is a vertex-labeled directed

graph �G = {V,L,E}, with vertices V , labels L, and directed edges E.
We denote the undirected topology graph by G.

The set of vertices V contains all Voronoi vertices and all index 2
saddle points. Its corresponding label set is L = {l(v)|v ∈ V}, where
l : V →{maximum,minimum,regular} is defined as follows. A vertex
v ∈V is called

• maximum, if v is a maximum in the Voronoi diagram.
• minimum, if v is an index 2 saddle in the Voronoi diagram. This

means that the index 2 saddle points in the Voronoi diagram turn
into minima in the topology graph. They represent the narrowest
points in the topology graph and later on the extracted paths.

• regular, if v is neither a maximum nor a minimum.

Now we construct the edges E of �G as follows. For each u ∈V with
l(u) = minimum, we add two directed edges (u,v) and (u,w), where v
and w are the vertices corresponding to the Voronoi edge on which u
lies. For each edge of the Voronoi diagram without an index 2 saddle
point, we add (u,v) to E if d(u) < d(v), where u and v are the cor-
responding vertices of the Voronoi edge. Note that the small random

2028 IEEE TRANSACTIONS ON VISUALIZATION AND COMPUTER GRAPHICS, VOL. 17, NO. 12, DECEMBER 2011



noise on the atom positions avoids d(u) = d(v), which is the degener-
ate case u = v. Furthermore v can be a regular vertex but also a max-
imum. Fig. 4 shows the topology graph of a Voronoi diagram for the
two-dimensional case. In the constructed topology graph, each mini-
mum has only outgoing edges, each maximum only incoming edges,
and each regular vertex incoming and outgoing edges.

Before we explain how we filter �G, we give some definitions con-
cerning an undirected graph Gs. A branch Gb is a connected subgraph
of Gs, where all vertices have at most two adjacent edges in Gs and
at least one vertex has a single edge in Gs. We call Gb regular, if all
vertices in Gb are regular. A branching vertex is a vertex with more
than two adjacent edges. We define a significant molecular path as a
path in G through a tunnel or into a cavity which starts and ends in a
branching vertex or a maximum and has at least one minimum. Fur-
thermore, there is no other path in G through this tunnel or into this
cavity that has a greater smallest minimum.

Note that we will sometimes speak of a sphere v instead of a vertex.
In this case, we mean the sphere with center v and radius d(v).

4.2 Path Filtering
In this section, we describe the complete filtering pipeline to obtain
the most significant molecular paths. We use five filtering methods
that are applied sequentially.

• Radius filter. This filter removes vertices from the topology
graph that are closer to the molecule than a pre-defined radius.

• Regular-branch filter. This filter removes branches from the
topology graph that do not contain critical points.

• Regular-edge filter. This filter removes single edges from the
topology graph. As a result of this, new regular branches emerge,
so we apply the regular-branch filter again after this step.

• Cycle filter. This filter removes cycles from the topology graph
to further simplify the graph structure.

• Branch filter. Finally, this filter removes branches that are al-
ready represented by more significant paths.

The graph that is left after applying all the filtering methods contains
all the paths we are interested in. Possibly, it still contains some dis-
pensable path segments, but only very few, so that the visual impres-
sion is not impaired. An example for a filtering is given in Fig. 6.

4.2.1 Radius Filter
This filter removes all edges along which a sphere with pre-defined ra-
dius r f cannot move without colliding with any atom of the molecule.
So all vertices whose distance value is smaller than r f are removed
from the graph, together with their adjacent edges.

The sphere with radius r f can be thought of as a very rough ap-
proximation of a small molecule interacting with the target molecule.
In case of a water molecule, r f is generally set to 1.4Å. When r f is
set to 0, the filter eliminates all edges that intersect the atoms of the
target molecule. The value of r f can be freely chosen according to the
molecule and the question of interest.

4.2.2 Regular-Branch Filter
In this filtering step, we operate on an undirected subgraph Gs of the
topology graph G and remove all regular branches from Gs (Sect. 4.1).
To identify regular branches, we start at any regular vertex of Gs that
has only a single edge and collect all vertices in a depth-first-search
manner. When we arrive at a vertex that is not regular or has more than
two edges, we stop. We remove all vertices found during the depth-
first search except the last one. As a result of this step, we might create
isolated maxima which we also remove.

We apply this filter after the radius filter as well as after the filter
that will be described in the next section. To illustrate the usefulness of
this filter, we give two examples. First, imagine a simple tunnel with a
minimum in the middle of the tunnel and two paths of regular vertices
to the maxima at the ends of the tunnel. After removing the minimum
by applying the radius filter, it does not make sense to keep branches

(a)

(b)

(c)

s

m

Fig. 5. Two-dimensional sketch of cycle elimination. Image (a) shows
the cycle detection algorithm for cycles of length 2, starting in s going to
the right. The red paths fail, the green is the cycle and the dotted path
will be removed. Image (b) shows a non-empty cycle. If we remove
the minimum m in image (c), we get two branches with a common start
vertex, so the smaller branch will be removed (dotted).

into the tunnel, because the connection is lost. Another example is a
simple cavity. Assume the graph has a single minimum at the entrance
to the cavity. If this minimum is removed, we can also remove the path
to the cavity, since the cavity is not accessible.

4.2.3 Regular-Edge Filter
We now describe a filtering step that simplifies the graph by removing

edges. In this step, we consider a subgraph �Gs of the directed topology
graph �G. From �Gs we remove edges outgoing from regular vertices,
such that after this step, for each regular vertex, there will be only one
outgoing edge. The motivation for this step is to break cycles but also
to remove paths to maxima that are of less interest. After this step, we
again apply the regular-branch filter described in Sect. 4.2.2.

In this filter, we consider all regular vertices v ∈ �Gs with more than
one outgoing edge. For each v, we follow all outgoing edges up to the
next maximum and compare the outgoing edges. We then remove all
outgoing edges that are of less interest to us. Several criteria for the
selection of the best outgoing edge are possible, for example, we can
consider the length of their paths or the maxima they lead to. In our
implementation, we always keep the outgoing edge that leads to the
closest maximum. This can again be decided using depth-first search.

As a result of this filter, some maxima may become isolated and will
finally get removed. These maxima are of no interest to us, since they
are not directly connected to a minimum via a separate path. Note
that a significant path contains at least one minimum and this filter
does not remove minima. Hence, all significant paths remain and each
minimum is connected to at most two maxima.

4.2.4 Cycle Filter
At this point, the filtered undirected topology graph still contains many
insignificant paths which connect vertices of the graph that are already
connected by more important paths. To remove the less significant
paths, we apply a two-step approach. First, we identify empty cy-
cles containing these paths, where a cycle is defined as being empty
if it can be shrunk linearly to its center of gravity without cutting any
atom. Second, for each empty cycle, we remove its smallest mini-
mum and its adjacent branches. We remove empty cycles depending
on their lengths, where the length of a cycle is given by the number of
contained minima. We start the path elimination with cycles of length
1 and continue up to a user-defined length. To identify cycles of length
k, we start the search at all minima.

To find a cycle of length k for a minimum m, we apply a modified re-
cursive depth first search with backtracing on the undirected topology
graph. Since each minimum is connected to exactly two vertices, we
can start the search at one of them and try to reach the other one. The
algorithm marks all visited vertices and unmarks them during back-
tracing. During the depth first search, we count all visited minima.

2029LINDOW ET AL: VORONOI-BASED EXTRACTION AND VISUALIZATION OF MOLECULAR PATHS



(a) (b) (c) (d) (e)

Fig. 6. The results of the path computation pipeline illustrated from left to right for a Chaperonin protein (PDB: 1AON). The color illustrates the
distance from black (3Å) to yellow (maximal distance). (a) Bounding box clipping. (b) Boundary handling. (c) Radius filter (r f = 3Å). (d) Regular-
branch filter, Regular-edge filter, and cycle filter. (e) Branch filter and removal of small components.

When we reach the end vertex and the number of visited minima is
equal to k− 1, we have found a cycle of length k and we store the
cycle in a global list. If we reach a vertex that is smaller than m or
the number of encountered minima exceeds k, we backtrace to the last
branch. In our implementation, we use a vertex stack to store the cycle.
An example for the detection of an empty cycle is shown in Fig. 5.

Before we can eliminate a cycle, we need to test it for emptiness.
We use a geometric heuristic that casts rays from the center of the cycle
to regularly sampled points on the cycle (see Fig. 5). The points must
be close enough so that we do not miss any atom possibly residing
in the cycle. If no ray hits an atom before reaching the point on the
cycle, the cycle is empty and can be removed. The tests for intersection
of a ray with the molecule can be done very fast using the grid data
structure described in Sect. 3.2.3. Finally, we remove the cycle by
deleting the smallest minimum on the cycle together with its adjacent
branches. Sometimes both branches start in the same vertex. In this
case, only the branch with the smallest vertex will be removed, shown
in Fig. 5.

4.2.5 Branch Filter

The goal of this filter is to remove short branches and branches that
are close to other branches. To identify branches that can be removed,
we consider the end vertex v of each branch Gb and test v’s sphere
for intersection with the spheres of all vertices w not belonging to Gb.
In the following, we will speak of sphere u instead of vertex u, by
which we mean the sphere centered at u with radius d(u). If we do
not find a vertex w such that the radius of the intersection circle of the
spheres v and w is greater than r f , we keep the branch. Otherwise, we
collect all vertices ṽ on Gb. If we find for each sphere ṽ a sphere w̃
such that the radius of their intersection circle is greater than r f , we
can remove Gb. Here, an intersection circle with radius greater than
r f means that a sphere of radius r f can move freely from one vertex
to the other. Thus, the vertices are not separated. Note that we sort the
branches according to the distance value of their end vertices, starting
with the smallest distance. This way it is guaranteed that we remove
the branches with smaller distance at the end points.

4.3 Path Selection

The filtered topology graph provides an overview of all possible
molecular paths. This allows the user to select paths that are of par-
ticular interest. The selected paths might then be further investigated.
We describe methods to visualize selected paths in Sect. 5. Here, we
explain how paths are selected from the undirected filtered topology
graph given a start vertex s and an end vertex t. We describe the com-
putation of the k best paths from s to t. In order to apply a variant
of Dijkstra’s shortest path algorithm, we need to define weights on
the edges of the graph. To compute the shortest path in terms of dis-
tance, one can simply use the length of an edge as its weight. Petrěk et
al. [38] use edge weights that also take the distance transform into ac-
count. Using their formula, paths with larger distance to the molecule
are preferred over paths that get close to the molecule.

Our goal is to compute the k best paths from s to t such that for all
paths j = 1 . . .k, it holds that (1) j contains at least one edge that is not
contained in any of the paths 1 to j−1, and (2) there is no shorter path
for which (1) is true. Since (1) is generally not guaranteed by other
k-shortest path algorithms, we developed the following procedure.

First, we compute the shortest path from s to t using the Dijkstra al-
gorithm and mark all vertices and edges of this path. For each marked
vertex, we store the distance to s and the distance to t. Now assume
that we have already found the j− 1 shortest paths and have marked
all their vertices and edges, and stored the shortest distances to the pri-
mary start vertex s and the end vertex t. To find the j’th shortest path
from s to t, we search for the shortest detour of the previous paths. To
do so, we start the Dijkstra algorithm at each marked vertex v which is
initialized with the shortest distance to s. The Dijkstra algorithm must
follow only unmarked edges to guarantee (1). If the algorithm reaches
another marked vertex u, we sum up the new minimal distances from
s to v, v to u, and u to t. If the distance of the next vertex in the heap is
greater than the length of the current minimal path, we have found the
shortest detour via v. The j’th shortest path is defined by the shortest
detour of all marked vertices. We repeat this until we have found the k
shortest paths.

5 VISUALIZATION

The user of our program should be able to visually explore the results
in a fast and intuitive way. We implemented several methods to vi-
sualize the molecules and their paths using state-of-the-art rendering
techniques. Using adaptations and combinations of them, we obtain
comprehensible high quality images at interactive speed.

All our implementations were carried out using the Open Graph-
ics Library (OpenGL) [1] and shader programs of the OpenGL Shad-
ing Language (GLSL) [41]. In the following sections, we present our
methods for visualizing the extracted paths and the molecular structure
according to these paths.

5.1 Molecule Rendering

There are several possibilities to render a molecular structure. In our
program, we provide the typical atom based visualizations like ball-
and-stick and molecular surfaces like van der Waals surface, solvent
accessible surface, solvent excluded surface and molecular skin sur-
face. The rendering of the ball-and-stick model is based on the work
of Sigg et al. [44], while the computation and rendering of the molec-
ular surfaces is based on the works of Krone et al. [25] and Lindow et
al. [31]. The raycasting based rendering techniques provide fast and
high quality visualizations.

The direct illumination of molecular structures, however, does not
provide good depth cues. This makes it difficult to detect cavities and
tunnels by pure visual inspection. To overcome this, we use screen
space ambient occlusion developed by [5]. This method provides a
much better depth perception and is easy to implement. In Sect. 5.4.1
we present a novel technique to further improve the visual perception
of cavities and tunnels using the extracted paths.

2030 IEEE TRANSACTIONS ON VISUALIZATION AND COMPUTER GRAPHICS, VOL. 17, NO. 12, DECEMBER 2011



Fig. 7. The KirBac1.1 potassium channel (PDB: 1P7B) with different illumination techniques. From left to right: direct illumination only, after adding
point lights on the filtered paths, after adding screen space ambient occlusion, and after adding the blur effect for glow impression.

5.2 Topology Graph Rendering
To visualize the significant molecular paths, we display the undirected
topology graph. Because of the sharp bends in the graph created by
the Voronoi diagram, we smooth the graph using non-uniform rational
basis splines (NURBS). The NURBS are rendered as short segments
of cylinders or cones with spheres at the ends of the spline. For the
rendering, we use raycasting of quadrics [44]. With each sampled
point on the spline, we store the distance to the nearest atom. We
visualize the distance either by color-coding or by scaling the radii of
the splines.

5.3 Rendering of Selected Paths
Besides the actual location of a selected path, the most interesting in-
formation about the path is the size of the empty area surrounding it.
Similarly to other works [38, 48], we visualize this area by rendering
the extension surface enclosing the spheres positioned at the vertices
v along the path. As sphere radii we use d(v) (see Eq. 1). In contrast
to previous approaches, however, we visualize the extension surface
using the skin surface developed by Edelsbrunner [14]. The skin sur-
face is a tangent continuous surface of a set of spheres. It has only a
single parameter, the so-called shrink factor. The shrink factor takes a
value between 0 and 1, where a value close to 0 creates a surface close
to the convex hull of the spheres, while a value of 1 creates a surface
enclosing exactly the spheres. To render the skin surface, we use the
raycasting approach presented in [31]. Since the creation of the ex-
tension surface is very fast, the user can interactively switch between
paths and visualize more than one path. We use a shrink factor around
0.7, which creates smooth extension surfaces and avoids intersections
with the molecular surface. Example images are given in Fig. 1.

5.4 Molecules and Paths
One of the most challenging problems in visualizing paths is to display
the extracted paths together with their surrounding molecular geome-
try. In the following paragraphs, we address this problem.

5.4.1 Illumination
In this paragraph, we present a novel technique for path visualization
that places many small point lights on the paths to draw the user’s
attention to channels and cavities reached by the paths. Results of this
technique can be seen in Fig. 7.

In order to guarantee a high visual quality as well as interactive
speed for many light sources, we use deferred shading [42, 18], which
was developed to reduce the costs of illumination to the number of
pixels in the final image instead of lighting all fragments of the scene
including hidden ones. By using multiple render targets, we first ren-
der the molecule without illumination. We store the color, the normal
and the depth of each fragment in three textures. If we want to com-
bine the technique with ambient occlusion, we do this in the second
pass, which then also makes use of the stored depth and normal tex-
tures. In the last pass, we compute the illumination of the point lights
and combine the result with the current image.

Because we create some thousand lights, it is not possible and not
necessary to consider all lights for the lighting of each fragment. In-
stead, we only use lights close to the fragment. To do so, we ap-
ply a three-dimensional grid similar to the grid of atoms described in
Sect. 3.2.3. For each cell of the three-dimensional grid, we store the
light sources in a two-dimensional texture.

Each point light is defined by its position and a radius, both of which
are stored in one floating point RGBA pixel. In our implementation,
the light color is fixed, but it could also be stored in another texture.
The strength of the light fades out linearly with the distance to the
position of the light. Each grid cell points to the pixel of its first light
in the texture. The rest of the lights of the cell follows behind until the
radius becomes negative which defines the end of the cell. The grid
itself is represented by a three-dimensional texture. The radius of each
point light is set depending on the distance value d(v) at vertex v. To
take effect, the radius must be larger than d(v). In our implementation,
we use a radius of min(2 ·d(v),4 · r f ).

During illumination, for each fragment, we compute the block of
cells according to the maximum light radius, that is 4 ·r f . We fetch the
lights of the cells and compute simple diffuse lighting. To avoid dark-
ness at positions without paths, we add a weak directional headlight.

Working with many lights often creates white artificial areas due to
color clamping. To solve this problem, we use high dynamic range
(HDR) rendering. A simple tone mapping function maps values in
[0,∞) to [0,1]. Together with gamma correction, a much better illumi-
nation is obtained.

To make the illumination more intuitive, we allow adding a glow
effect at the boundary of the molecule. To do so, for each fragment not
belonging to the molecular structure, we collect all the colors within
a certain radius. The new fragment color is set to the average of the
collected colors.

5.4.2 Surface Clipping

The methods presented so far enable the user to get a good overview
of the interesting cavities and tunnels. They also allow one to view the
extension surface of one or more selected paths alone or together with,
for example, the ball-and-stick representation. But if the molecule is
very complex, it becomes difficult to follow the selected paths.

To solve this problem, we propose a simple but effective method:
we clip the molecular structure, in particular the molecular surface us-
ing the extension surface of the selected paths. A similar technique
was previously used by Jones et al. [20] for visualizing flow trajecto-
ries together with volume data.

There are several possibilities to realize the clipping, so we describe
our method in detail. The first step is to render the extension surface
into a frame buffer object without illumination, since we are only in-
terested in the depth values. In contrast to the default rendering, where
the closest depth values to the camera are stored, we clear the depth
buffer with 0 and store the farthest depth values into a texture. During
rendering of the molecular structure, we read this texture and discard
all fragments closer to the camera than the values given by the texture.

2031LINDOW ET AL: VORONOI-BASED EXTRACTION AND VISUALIZATION OF MOLECULAR PATHS



Two more features help to distinguish between the area behind the
cut and the rest of the structure. First, for all fragments with a depth
value of 0 in the texture, the surrounding depth values within a given
radius are checked. The ratio rcol between the number of depth values
equal to 0 and the overall number of values is used to color the cutting
boundary. The final pixel color cpix is determined by

cpix = rcol · csur f +(1− rcol) · cbound ,
where csur f is the color of the molecular surface and cbound is the
boundary color. The result can be seen, for example, in Fig. 8, where
the boundary appears to be black. As a second feature, the brightness
of all fragments behind the cut is changed by a user-defined value. In
Fig. 8, the pixel values behind the cut have been brightened.

6 RESULTS
In this section, we present times for the computation of the Voronoi
diagram, for the path filtering, and for rendering. Furthermore,
we present some application results. Timings for the computation
of the molecular surface and the skin surface can be found else-
where [25, 31]. They are negligible in comparison to the computation
of the Voronoi diagram and the path filtering.

We applied our methods to several molecules from the PDB [37].
The PDB IDs of these molecules together with the number of atoms
of each molecule can be found in Tab. 1. We also applied our methods
to a dendritic core multi-shell nanotransporter (CMS-NT).

All results presented here were obtained on an Intel Xeon X5650
E5540 2.66 GHz system with 6 cores and an NVIDIA Geforce
GTX470 graphics card.

6.1 Voronoi Diagram Computation
We tested the Voronoi diagram algorithm on several molecules from
the PDB. We ran the algorithm on a single core as well as on multiple
cores using OpenMP [2]. The computation times for 1 and 6 cores are
given in Tab. 1. We also ran the algorithm on other machines with up to
8 cores. On all machines, we found that the speed-up is approximately
0.5 ·c, where c is the number of cores. The theoretical time complexity
of the algorithm is O(n ·e) [21], where n is the number of input spheres
and e is the number of Voronoi edges. But with the improvements of
Kim et al. [10] and our grid data structure (see Sect. 3.2.3), for the
tested PDB molecules with up to 100,000 atoms, the algorithm scales
almost linearly with the number of atoms. We compared our results
with Man̆ák et al. [33], who are the only ones presenting timings for
molecules of the PDB. Like Man̆ák we used an Intel Core 2 QUAD 2.4
GHz system. We tested several molecules on one core and measured
that our Voronoi diagram computation is about two times faster. For
the protein PDB: 1HX6 it takes 5.8 seconds in contrast to 11.2 seconds
by Man̆ák’s algorithm. The boundary handling depends on the number
of rays and the hit ratio (see Sect. 3.2.4). In all our tests, we fixed the
number of rays to 100 and the hit ratio to 0.5. The timings for one
and six cores are given in Tab. 1. The timings show that the boundary
handling scales linearly with the number of atoms. Furthermore, we
see that it is the most expensive part in the computation pipeline. The
speedup for six cores is around 5.5.

Table 1. Computation times in seconds of the Voronoi diagram (VD),
the boundary handling (BH) and the filtering (F). The VD and BH were
computed with 1 and 6 cores using OpenMP.

PDB ID #Atoms VD BH r f F

1 6 1 6

2OAU 13573 5.2 1.6 10.4 1.9 1.0 3.3

1GKI 20150 7.3 2.3 13.6 2.4 1.4 2.6

1G3I 46040 18.9 5.8 36.2 6.4 2.0 4.6

1AON 58870 23.7 7.5 46.9 8.6 3.0 4.0

1JJ2 98543 44.1 13.4 82.9 15.2 1.4 13.3

System: Intel Xeon X5650 E5540 2.66 GHz.

Fig. 8. Molecular paths of the CMS nanotransporter with a camera zoom
(right) and surface clipping for user-selected paths (red). The top im-
ages show paths with radii of at least 3Å, approximating a morphine
molecule. The paths do not reach the inner core, but cavities in the
outer shell. The paths in the bottom images have radii of at least 1.4Å,
which approximates water. Molecules of this size can reach the inner
core.

6.2 Path Filtering and Selection
The results of the filtering depend on two parameters, which are the
filter radius r f (see Sect. 4.2.1) and the maximal size of cycles that
are considered for empty cycle cancellation (see Sect. 4.2.4). We kept
the maximal cycle size to the fixed value of 20 and varied only the
filter radius r f . The filter radius r f as well as the accumulated filter
timings are given in Tab. 1. We found that the cycle filter is the most
expensive one. Its speed depends mainly on the complexity of the
remaining graph and the maximum cycle size. The more elements
are removed by the boundary handling and radius filters, the faster
the cycle filter works. The remaining filters are very fast and scale
linearly with the number of atoms. Overall, the speed of all filtering
steps is still fast enough to allow filtering within several seconds. In
contrast, CHUNNEL [11] takes several hours to detect all channels in
molecules with only a few thousand atoms.

From the filtered paths, the user of our program can interactively
select start and end vertices and compute the k best paths between the
selected vertices. This takes at most a few seconds for k ≤ 10.
6.3 Rendering
We measured the rendering times for the same molecules and the same
path extraction parameters as given in Sect. 6.2. The images were ren-
dered with a fixed image size of 1024×1024 and a varying complexity
of illumination as shown in Fig. 7. The frame rates are given in Tab. 2.
The paths were rendered as cylindrical lines and the molecular struc-
ture using the solvent excluded surface (SES).

The fastest rendering is achieved with only a single directional head
light. To add complexity, we then turned on the point lights given
by the filtered paths as well as the screen space ambient occlusion
(SSAO). Finally, we added a glow effect. Even with the most expen-
sive illumination, we still achieve 9 frames per second and more.

We also tested the performance of the rendering when clipping the
molecular surface using the extension surface of the selected paths.
Of course, the performance depends on the complexity and size of the

2032 IEEE TRANSACTIONS ON VISUALIZATION AND COMPUTER GRAPHICS, VOL. 17, NO. 12, DECEMBER 2011



Table 2. Rendering performance given in frames per second w.r.t. a
given fill rate (FR). First, we rendered the SES and the paths only with
one directional head light (DL), then we added the point lights (PL), the
screen space ambient occlusion (SSAO), and finally the glow effect.

PDB ID FR(%) DL #PL +PL +SSAO +Glow

2OAU 65 61 36897 27 19 13

1GKI 65 45 19655 24 18 12

1G3I 55 43 21539 20 15 10

1AON 55 42 10787 22 15 10

1JJ2 83 28 101201 16 12 9

Graphics card: NVIDIA Geforce GTX470.

selected paths. Nevertheless, we did not recognize great performance
losses. For example, if we clip the main path in the middle of 1AON,
the performance dropped only from 15 to 13 frames per second.

6.4 Application Results
In Fig. 8, we show the filtered paths of a dendritic core multi-shell nan-
otransporter (CMS-NT). The left images show all extracted paths for
two different filter radii. The top images display the paths of molecules
approximated by a radius of 3Å. A sphere of this size approximates a
morphine molecule. We did not find any path reaching the core of the
molecule. Only cavities in the outer shell are reached; one is depicted
in the right image. In the bottom images, we filtered the paths using a
filter radius of 1.4Å, which is the size of a water molecule. In the right
image, we selected a path going through the core of the molecule.

Another example is given in Fig. 9, which shows the feasible
sodium channels in 3HGC. These channels are accessible for NA+
ions but can be blocked by amiloride. Note that NA+ ions and
amiloride have approximate radii of 1Å and 2.5Å, respectively. The
image shows the paths extracted using a filter radius of 1Å. As can be
expected from the 3-fold rotational symmetry of 3HGC, the extracted
paths also show such a symmetry.

7 DISCUSSION AND CONCLUSION
In this paper, we presented several improvements for the computation
and visualization of potential molecular paths.

By computing the molecular paths from the Voronoi diagram of
spheres, we are able to extract the paths from the exact distance trans-
form of the molecule in contrast to others [38, 34, 48], who use ap-
proximations. Our Voronoi diagram computation is about two times
faster than that presented by Man̆ák et al. [33]. One reason might be
the overhead by computing the Delaunay complex for a fast neighbor
search. We also tested the program by Medvedev et al. [35]. However,
their algorithm is restricted to data with periodic boundary, which al-
lows them to use a simpler edge direction detection, which fails for
typical proteins. After several minutes, we terminated their program.

From the Voronoi diagram of spheres, we compute the most sig-
nificant paths by applying a sequence of methods. Among these, the
boundary handling is the most expensive one. We thought about two
alternatives. First, we could cut all vertices v of the Voronoi diagram
with d(v) greater than a given value. Such a filtering would be very
fast, but it would also eliminate paths inside large cavities. A sec-
ond alternative is to use a mask approximating the structure of the
molecule. However, creating such a mask would involve user interac-
tion and might be time consuming for complex molecules. Our bound-
ary handling seems a good compromise between fast computation and
good boundary estimation. Furthermore, we compute the hit ratio only
once and store it. The fixed ratio of 0.5 in our tests, cuts the paths ap-
proximately at the convex hull (see Sect. 3.2.4), like in many other
molecular path detection algorithms. A cut with the convex hull can
be done much faster, but with our approach the user can change the
ratio to keep for example only paths deep inside the molecule. Empir-
ically, 100 rays seemed enough to cover the domain around a vertex.
We believe that an implementation for graphics cards would greatly
accelerate this method. For the regular-edge filter, we also tried other

Fig. 9. Sodium ion channel (PDB: 3HGC). The channel is important for
epidermal ion transport into the cell. Blocking this channels by amiloride
is a way to treat cystic fibrosis.

heuristics. For example, we kept the edge with the largest distance
slope or the edge of the path leading to the largest maximum. How-
ever, we did not recognize great differences in the results.

To the best of our knowledge, our approach is the first which detects
all paths through tunnels as well as into cavities. In comparison to
CHUNNEL [11], which is able to detect all paths through tunnels, our
approach is faster by at least two orders of magnitude. Our filtering
keeps only the significant paths containing the main paths extracted
also by others, compare to [8, 11, 38, 39]

Our interactive rendering with the combination of screen space am-
bient occlusion and the novel lighting of channels and cavities pro-
vides a very good depth impression and allows one to quickly identify
the important areas. Nevertheless, it can be difficult to understand still
pictures, because it is more intuitive for the user to see dark cavities,
where typically no light exists. To make the illumination more con-
sistent and the visualization more intuitive, we use a dark background
and a blur effect at the boundary, which creates the impression of glow.

Instead of using lights, we could also color the molecular surface
according to the distance to the paths. Illumination, however, has the
advantage, that we can still use the color to display other properties of
the molecule. One other advantage is that we can also use the lights for
dynamic illumination of selected paths only and for path animation.

The complete overview of all potential paths enables the user to
quickly find the interesting ones. These paths can be further investi-
gated by interactive selection. We visualize selected paths by display-
ing their extension surface, which was also done by Petrěk et al. [38]
and Yaffe et al. [48]. In contrast to their methods, we visualize the
extension surface using a raycasted skin surface. This is much faster,
since we do not need to triangulate the surface. Furthermore, we can
easily apply it to several selected paths. We also use the extension sur-
face to clip the molecular structure. This greatly improves the under-
standing of the location of the paths w.r.t. to the molecular structure.

So far, we have only used the extracted paths for visualization. In
the future, we plan to use the paths for guiding molecular simulations.
The precomputed potential paths can reduce the computational cost of
such simulations, since large parts of the search space can be excluded.
Furthermore, we want to compute paths depending on the geometry
and dynamic of the substrate, instead of paths only for spheres.

ACKNOWLEDGMENTS

We would like to thank Marcus Weber and Amir Sedighi from Zuse In-
stitute Berlin (ZIB) for providing the CMS-NT structure and for many
helpful discussions.

2033LINDOW ET AL: VORONOI-BASED EXTRACTION AND VISUALIZATION OF MOLECULAR PATHS



REFERENCES

[1] OpenGL Webseite, 2009. http://www.opengl.org/.

[2] OpenMP Webseite, 2009. http://www.openmp.org/.

[3] F. Aurenhammer. Power diagrams: properties, algorithms and applica-

tions. SIAM J. Comput., 16:78–96, February 1987.
[4] C. Bajaj, A. Gillette, and S. Goswami. Topology based selection and

curation of level sets. In H.-C. Hege, K. Polthier, and G. Scheuermann,

editors, Topology-Based Methods in Visualization II, Mathematics and
Visualization, pages 45–58. Springer Berlin Heidelberg, 2009.

[5] L. Bavoil, M. Sainz, and R. Dimitrov. Image-space horizon-based am-

bient occlusion. In ACM SIGGRAPH 2008 talks, SIGGRAPH ’08, New
York, NY, USA, 2008. ACM.

[6] K. Bidmon, S. Grottel, F. Bös, J. Pleiss, and T. Ertl. Visual abstractions

of solvent pathlines near protein cavities. Computer Graphics Forum,
27(3):935–942, 2008.

[7] D. Borland. Ambient occlusion opacity mapping for visualization of in-

ternal molecular structure. Journal of WSCG, 19(1):17–23, 2011.
[8] M. P. Calace, T. Maiwald, and J. M. Thornton. PoreWalker: A novel tool

for the identification and characterization of channels in transmembrane

proteins from their three-dimensional structure. PLoS Computational Bi-
ology, 5(7), 2009.

[9] M. Chavent, B. Lévy, and B. Maigret. High quality visualization of

molecular skin surface. Journal of Molecular Graphics and Modelling,
27(2):1391–1398, 2008.

[10] Y. Cho, D. Kim, H. Lee, J. Park, and D.-S. Kim. Reduction of the search

space in the edge-tracing algorithm for the Voronoi diagram of 3d balls.

In Computational Science and Its Applications - ICCSA 2006, volume
3980 of Lecture Notes in Computer Science, pages 111–120. Springer
Berlin / Heidelberg, 2006.

[11] R. G. Coleman and K. A. Sharp. Finding and characterizing tunnels in

macromolecules with application to ion channels and pores. Biophys. J.,
96:632–645, Oct. 2008.

[12] J. Cortes, S. Barbe, M. Erard, and T. Simeon. Encoding molecular mo-

tions in voxel maps. IEEE/ACM Trans. Comput. Biol. Bioinformatics,
8:557–563, March 2011.

[13] J. Cortes, T. Simon, V. R. de Angulo, D. Guieysse, M. Remaud-Simeon,

and V. Tran. A path planning approach for computing large-amplitude

motions of flexible molecules, 2005.

[14] H. Edelsbrunner. Deformable smooth surface design. Discrete & Com-
putational Geometry, 21(1):87–115, 1999.

[15] H. Edelsbrunner and E. P. Mücke. Three-dimensional alpha shapes. ACM
Trans. Graph., 13:43–72, January 1994.

[16] T. Exner, M. Keil, G. Möckel, and J. Brickmann. Identification of sub-

strate channels and protein cavities. Journal of Molecular Modeling,
4:340–343, 1998.

[17] M. L. Gavrilova and J. Rokne. Updating the topology of the dynamic

Voronoi diagram for spheres in euclidean d-dimensional space. Comput.
Aided Geom. Des., 20:231–242, July 2003.

[18] S. Hargreaves. Deferred shading. Game Developers Conference (GDC)

talks, 2004.

[19] B. K. Ho and F. Gruswitz. HOLLOW: Generating accurate represen-

tations of channel and interior surfaces in molecular structures. BMC
structural biology, 8(1):49+, Nov. 2008.

[20] C. Jones and K.-L. Ma. Visualizing flow trajectories using locality-based

rendering and warped curve plots. IEEE Transactions on Visualization
and Computer Graphics, 16:1587–1594, November 2010.

[21] D.-S. Kim, Y. Cho, and D. Kim. Euclidean Voronoi diagram of 3d

balls and its computation via tracing edges. Computer-Aided Design,
37(13):1412 – 1424, 2005.

[22] D.-S. Kim, Y. Cho, and K. Sugihara. Quasi-worlds and quasi-operators

on quasi-triangulations. Comput. Aided Des., 42:874–888, October 2010.
[23] D.-S. Kim, D. Kim, Y. Cho, and K. Sugihara. Quasi-triangulation and

interworld data structure in three dimensions. Computer-Aided Design,
38(7):808 – 819, 2006.

[24] G. J. Kleywegt and T. A. Jones. Detection, delineation, measurement and

display of cavities in macromolecular structures. Acta Crystallographica
Section D, 50(2):178–185, Mar. 1994.

[25] M. Krone, K. Bidmon, and T. Ertl. Interactive visualization of molecular

surface dynamics. IEEE Transactions on Visualization and Computer
Graphics, 15(6):1391–1398, 2009.

[26] M. Krone, M. Falk, S. Rehm, J. Pleiss, and T. Ertl. Interactive exploration

of protein cavities. To appear in Computer Graphics Forum (Proceedings

of EG/IEEE EuroVis 2011), 2011.
[27] S. Küchler, M. Radowski, T. Blaschke, M. Dathe, J. Plendl, R.Haag,

M. Schäfer-Korting, and M. Kramer. Nanoparticles for skin penetra-

tion enhancement - A comparison of a dendritic coremultishell nan-

otransporter and solid lipid nanoparticles. Eur. J. Pharm. Biopharm.,
71(2):243–250, 2009.

[28] R. A. Laskowski. Surfnet: A program for visualizing molecular surfaces,

cavities, and intermolecular interactions. Journal of Molecular Graphics,
13(5):323 – 330, 1995.

[29] S. M. Lavalle. Rapidly-exploring random trees: A new tool for path

planning, 1998.

[30] J. Liang, H. Edelsbrunner, and C. Woodward. Anatomy of protein pock-

ets and cavities: measurement of binding site geometry and implications

for ligand design. Protein science: a publication of the Protein Society,
7(9):1884–1897, Sept. 1998.

[31] N. Lindow, D. Baum, S. Prohaska, and H.-C. Hege. Accelerated visu-

alization of dynamic molecular surfaces. Computer Graphics Forum,
29(3):943–952, 2010.

[32] M. H. Maeda and K. Kinoshita. Development of new indices to evaluate

protein-protein interfaces: Assembling space volume, assembling space

distance, and global shape descriptor. Journal of Molecular Graphics and
Modelling, 27(6):706 – 711, 2009.

[33] M. Man̆ák and I. Kolingerová. Fast discovery of Voronoi vertices in

the construction of Voronoi diagram of 3d balls. In Proceedings of the
2010 International Symposium on Voronoi Diagrams in Science and En-
gineering, ISVD ’10, pages 95–104, Washington, DC, USA, 2010. IEEE
Computer Society.

[34] P. Medek, P. Beneš, and J. Sochor. Computation of tunnels in protein

molecules using Delaunay triangulation. Journal of WSCG, University of
West Bohemia, Pilsen, 15(1-3):107–114, 2007.

[35] N. N. Medvedev, V. P. Voloshin, V. A. Luchnikov, and M. L. Gavrilova.

An algorithm for three-dimensional Voronoi s-network. Journal of Com-
putational Chemistry, pages 1676–1692, 2006.

[36] A. Okabe, B. Boots, K. Sugihara, and S. N. Chiu. Spatial tessellations:
Concepts and applications of Voronoi diagrams. Probability and Statis-
tics. Wiley, NYC, 2nd edition, 2000. 671 pages.

[37] Protein Data Bank. http://www.pdb.org.

[38] M. Petrěk, P. Kosinová, J. Koca, and M. Otyepka. MOLE: A Voronoi

diagram-based explorer of molecular channels, pores, and tunnels. Struc-
ture, 15(11):1357 – 1363, 2007.

[39] M. Petrěk, M. Otyepka, P. Banas, P. Kosinová, J. Koca, and J. Damborsky.

CAVER: a new tool to explore routes from protein clefts, pockets and

cavities. BMC Bioinformatics, 7(1):316+, June 2006.
[40] M. Raunest and C. Kandt. dxTuber: Detecting protein cavities, tunnels

and clefts based on protein and solvent dynamics. Journal of Molecular
Graphics and Modelling, 2010.

[41] R. J. Rost. OpenGL(R) Shading Language (2nd Edition). Addison-
Wesley Professional, January 2006.

[42] T. Saito and T. Takahashi. Comprehensible rendering of 3-d shapes. vol-

ume 24, pages 197–206, New York, NY, USA, September 1990. ACM.

[43] D. Siersma. Voronoi diagrams and Morse theory of the distance function.

In Geometry in Present Day Science, World Scientific, pages 187–208.
World Scientific, 1999.

[44] C. Sigg, T. Weyrich, M. Botsch, and M. Gross. GPU-based ray-casting

of quadratic surfaces. In Proceedings of the Eurographics Symposium on
Point-Based Graphics, pages 59–65, 2006.

[45] O. S. Smart, J. G. Neduvelil, X. Wang, B. A. Wallace, and M. S. Sansom.

HOLE: a program for the analysis of the pore dimensions of ion channel

structural models. Journal of Molecular Graphics, 14(6), Dec. 1996.
[46] M. Tarini, P. Cignoni, and C. Montani. Ambient occlusion and edge

cueing for enhancing real time molecular visualization. IEEE Transac-
tions on Visualization and Computer Graphics, 12:1237–1244, Septem-
ber 2006.

[47] N. R. Voss and M. Gerstein. 3V: cavity, channel and cleft volume cal-

culator and extractor. Nucleic Acids Research, 38(suppl 2):W555–W562,
2010.

[48] E. Yaffe, D. Fishelovitch, H. J. Wolfson, D. Halperin, and R. Nussi-

nov. MolAxis: Efficient and accurate identification of channels in macro-

molecules. Proteins: Structure, Function, and Bioinformatics, 73(1):72–
86, 2008.

[49] J. Yu, Y. Zhou, I. Tanaka, and M. Yao. Roll: a new algorithm for the de-

tection of protein pockets and cavities with a rolling probe sphere. Bioin-
formatics, 26(1):46–52, Jan. 2010.

2034 IEEE TRANSACTIONS ON VISUALIZATION AND COMPUTER GRAPHICS, VOL. 17, NO. 12, DECEMBER 2011

















<<
  /ASCII85EncodePages false
  /AllowTransparency false
  /AutoPositionEPSFiles false
  /AutoRotatePages /None
  /Binding /Left
  /CalGrayProfile (None)
  /CalRGBProfile (None)
  /CalCMYKProfile (None)
  /sRGBProfile (sRGB IEC61966-2.1)
  /CannotEmbedFontPolicy /Error
  /CompatibilityLevel 1.6
  /CompressObjects /Off
  /CompressPages true
  /ConvertImagesToIndexed true
  /PassThroughJPEGImages true
  /CreateJobTicket false
  /DefaultRenderingIntent /Default
  /DetectBlends true
  /DetectCurves 0.1000
  /ColorConversionStrategy /LeaveColorUnchanged
  /DoThumbnails true
  /EmbedAllFonts true
  /EmbedOpenType false
  /ParseICCProfilesInComments true
  /EmbedJobOptions true
  /DSCReportingLevel 0
  /EmitDSCWarnings false
  /EndPage -1
  /ImageMemory 1048576
  /LockDistillerParams true
  /MaxSubsetPct 100
  /Optimize true
  /OPM 0
  /ParseDSCComments false
  /ParseDSCCommentsForDocInfo false
  /PreserveCopyPage true
  /PreserveDICMYKValues true
  /PreserveEPSInfo false
  /PreserveFlatness true
  /PreserveHalftoneInfo true
  /PreserveOPIComments false
  /PreserveOverprintSettings true
  /StartPage 1
  /SubsetFonts true
  /TransferFunctionInfo /Remove
  /UCRandBGInfo /Preserve
  /UsePrologue false
  /ColorSettingsFile ()
  /AlwaysEmbed [ true
  ]
  /NeverEmbed [ true
  ]
  /AntiAliasColorImages false
  /CropColorImages true
  /ColorImageMinResolution 36
  /ColorImageMinResolutionPolicy /Warning
  /DownsampleColorImages true
  /ColorImageDownsampleType /Bicubic
  /ColorImageResolution 300
  /ColorImageDepth -1
  /ColorImageMinDownsampleDepth 1
  /ColorImageDownsampleThreshold 2.00333
  /EncodeColorImages true
  /ColorImageFilter /DCTEncode
  /AutoFilterColorImages false
  /ColorImageAutoFilterStrategy /JPEG
  /ColorACSImageDict <<
    /QFactor 0.76
    /HSamples [2 1 1 2] /VSamples [2 1 1 2]
  >>
  /ColorImageDict <<
    /QFactor 0.76
    /HSamples [2 1 1 2] /VSamples [2 1 1 2]
  >>
  /JPEG2000ColorACSImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /JPEG2000ColorImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /AntiAliasGrayImages false
  /CropGrayImages true
  /GrayImageMinResolution 36
  /GrayImageMinResolutionPolicy /Warning
  /DownsampleGrayImages true
  /GrayImageDownsampleType /Bicubic
  /GrayImageResolution 300
  /GrayImageDepth -1
  /GrayImageMinDownsampleDepth 2
  /GrayImageDownsampleThreshold 2.00333
  /EncodeGrayImages true
  /GrayImageFilter /DCTEncode
  /AutoFilterGrayImages false
  /GrayImageAutoFilterStrategy /JPEG
  /GrayACSImageDict <<
    /QFactor 0.76
    /HSamples [2 1 1 2] /VSamples [2 1 1 2]
  >>
  /GrayImageDict <<
    /QFactor 0.76
    /HSamples [2 1 1 2] /VSamples [2 1 1 2]
  >>
  /JPEG2000GrayACSImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /JPEG2000GrayImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /AntiAliasMonoImages false
  /CropMonoImages true
  /MonoImageMinResolution 36
  /MonoImageMinResolutionPolicy /Warning
  /DownsampleMonoImages true
  /MonoImageDownsampleType /Bicubic
  /MonoImageResolution 600
  /MonoImageDepth -1
  /MonoImageDownsampleThreshold 1.00167
  /EncodeMonoImages true
  /MonoImageFilter /CCITTFaxEncode
  /MonoImageDict <<
    /K -1
  >>
  /AllowPSXObjects false
  /CheckCompliance [
    /None
  ]
  /PDFX1aCheck false
  /PDFX3Check false
  /PDFXCompliantPDFOnly false
  /PDFXNoTrimBoxError true
  /PDFXTrimBoxToMediaBoxOffset [
    0.00000
    0.00000
    0.00000
    0.00000
  ]
  /PDFXSetBleedBoxToMediaBox true
  /PDFXBleedBoxToTrimBoxOffset [
    0.00000
    0.00000
    0.00000
    0.00000
  ]
  /PDFXOutputIntentProfile (None)
  /PDFXOutputConditionIdentifier ()
  /PDFXOutputCondition ()
  /PDFXRegistryName (http://www.color.org)
  /PDFXTrapped /False

  /CreateJDFFile false
  /Description <<
    /JPN <FEFF3053306e8a2d5b9a306f300130d330b830cd30b9658766f8306e8868793a304a3088307353705237306b90693057305f00200050004400460020658766f830924f5c62103059308b3068304d306b4f7f75283057307e305930023053306e8a2d5b9a30674f5c62103057305f00200050004400460020658766f8306f0020004100630072006f0062006100740020304a30883073002000520065006100640065007200200035002e003000204ee5964d30678868793a3067304d307e30593002>
    /DEU <FEFF00560065007200770065006e00640065006e0020005300690065002000640069006500730065002000450069006e007300740065006c006c0075006e00670065006e0020007a0075006d002000450072007300740065006c006c0065006e00200076006f006e0020005000440046002d0044006f006b0075006d0065006e00740065006e002c00200075006d002000650069006e00650020007a0075007600650072006c00e40073007300690067006500200041006e007a006500690067006500200075006e00640020004100750073006700610062006500200076006f006e00200047006500730063006800e40066007400730064006f006b0075006d0065006e00740065006e0020007a0075002000650072007a00690065006c0065006e002e00200044006900650020005000440046002d0044006f006b0075006d0065006e007400650020006b00f6006e006e0065006e0020006d006900740020004100630072006f0062006100740020006f0064006500720020006d00690074002000640065006d002000520065006100640065007200200035002e003000200075006e00640020006800f600680065007200200067006500f600660066006e00650074002000770065007200640065006e002e>
    /FRA <FEFF004f007000740069006f006e00730020007000650072006d0065007400740061006e007400200064006500200063007200e900650072002000640065007300200064006f00630075006d0065006e007400730020005000440046002000700072006f00660065007300730069006f006e006e0065006c007300200066006900610062006c0065007300200070006f007500720020006c0061002000760069007300750061006c00690073006100740069006f006e0020006500740020006c00270069006d007000720065007300730069006f006e002e00200049006c002000650073007400200070006f0073007300690062006c0065002000640027006f00750076007200690072002000630065007300200064006f00630075006d0065006e007400730020005000440046002000640061006e00730020004100630072006f0062006100740020006500740020005200650061006400650072002c002000760065007200730069006f006e002000200035002e00300020006f007500200075006c007400e9007200690065007500720065002e>
    /PTB <FEFF005500740069006c0069007a006500200065007300740061007300200063006f006e00660069006700750072006100e700f5006500730020007000610072006100200063007200690061007200200064006f00630075006d0065006e0074006f0073002000500044004600200063006f006d00200075006d0061002000760069007300750061006c0069007a006100e700e3006f0020006500200069006d0070007200650073007300e3006f00200061006400650071007500610064006100730020007000610072006100200064006f00630075006d0065006e0074006f007300200063006f006d0065007200630069006100690073002e0020004f007300200064006f00630075006d0065006e0074006f0073002000500044004600200070006f00640065006d0020007300650072002000610062006500720074006f007300200063006f006d0020006f0020004100630072006f006200610074002c002000520065006100640065007200200035002e00300020006500200070006f00730074006500720069006f0072002e>
    /DAN <FEFF004200720075006700200064006900730073006500200069006e0064007300740069006c006c0069006e006700650072002000740069006c0020006100740020006f0070007200650074007400650020005000440046002d0064006f006b0075006d0065006e007400650072002c0020006400650072002000650072002000650067006e006500640065002000740069006c0020007000e5006c006900640065006c006900670020007600690073006e0069006e00670020006f00670020007500640073006b007200690076006e0069006e006700200061006600200066006f0072007200650074006e0069006e006700730064006f006b0075006d0065006e007400650072002e0020005000440046002d0064006f006b0075006d0065006e007400650072006e00650020006b0061006e002000e50062006e006500730020006d006500640020004100630072006f0062006100740020006f0067002000520065006100640065007200200035002e00300020006f00670020006e0079006500720065002e>
    /NLD <FEFF004700650062007200750069006b002000640065007a006500200069006e007300740065006c006c0069006e00670065006e0020006f006d0020005000440046002d0064006f00630075006d0065006e00740065006e0020007400650020006d0061006b0065006e00200064006900650020006700650073006300680069006b00740020007a0069006a006e0020006f006d0020007a0061006b0065006c0069006a006b006500200064006f00630075006d0065006e00740065006e00200062006500740072006f0075007700620061006100720020007700650065007200200074006500200067006500760065006e00200065006e0020006100660020007400650020006400720075006b006b0065006e002e0020004400650020005000440046002d0064006f00630075006d0065006e00740065006e0020006b0075006e006e0065006e00200077006f007200640065006e002000670065006f00700065006e00640020006d006500740020004100630072006f00620061007400200065006e002000520065006100640065007200200035002e003000200065006e00200068006f006700650072002e>
    /ESP <FEFF0055007300650020006500730074006100730020006f007000630069006f006e006500730020007000610072006100200063007200650061007200200064006f00630075006d0065006e0074006f0073002000500044004600200071007500650020007000650072006d006900740061006e002000760069007300750061006c0069007a006100720020006500200069006d007000720069006d0069007200200063006f007200720065006300740061006d0065006e0074006500200064006f00630075006d0065006e0074006f007300200065006d00700072006500730061007200690061006c00650073002e0020004c006f007300200064006f00630075006d0065006e0074006f00730020005000440046002000730065002000700075006500640065006e00200061006200720069007200200063006f006e0020004100630072006f00620061007400200079002000520065006100640065007200200035002e003000200079002000760065007200730069006f006e0065007300200070006f00730074006500720069006f007200650073002e>
    /SUO <FEFF004e00e4006900640065006e002000610073006500740075007300740065006e0020006100760075006c006c006100200076006f006900740020006c0075006f006400610020006a0061002000740075006c006f00730074006100610020005000440046002d0061007300690061006b00690072006a006f006a0061002c0020006a006f006900640065006e0020006500730069006b0061007400730065006c00750020006e00e400790074007400e400e40020006c0075006f00740065007400740061007600610073007400690020006c006f00700070007500740075006c006f006b00730065006e002e0020005000440046002d0061007300690061006b00690072006a0061007400200076006f0069006400610061006e0020006100760061007400610020004100630072006f006200610074002d0020006a0061002000520065006100640065007200200035002e00300020002d006f0068006a0065006c006d0061006c006c0061002000740061006900200075007500640065006d006d0061006c006c0061002000760065007200730069006f006c006c0061002e>
    /ITA <FEFF00550073006100720065002000710075006500730074006500200069006d0070006f007300740061007a0069006f006e00690020007000650072002000630072006500610072006500200064006f00630075006d0065006e007400690020005000440046002000610064006100740074006900200070006500720020006c00610020007300740061006d00700061002000650020006c0061002000760069007300750061006c0069007a007a0061007a0069006f006e006500200064006900200064006f00630075006d0065006e0074006900200061007a00690065006e00640061006c0069002e0020004900200064006f00630075006d0065006e00740069002000500044004600200070006f00730073006f006e006f0020006500730073006500720065002000610070006500720074006900200063006f006e0020004100630072006f00620061007400200065002000520065006100640065007200200035002e003000200065002000760065007200730069006f006e006900200073007500630063006500730073006900760065002e>
    /NOR <FEFF004200720075006b00200064006900730073006500200069006e006e007300740069006c006c0069006e00670065006e0065002000740069006c002000e50020006f00700070007200650074007400650020005000440046002d0064006f006b0075006d0065006e00740065007200200073006f006d002000700061007300730065007200200066006f00720020007000e5006c006900740065006c006900670020007600690073006e0069006e00670020006f00670020007500740073006b007200690066007400200061007600200066006f0072007200650074006e0069006e006700730064006f006b0075006d0065006e007400650072002e0020005000440046002d0064006f006b0075006d0065006e00740065006e00650020006b0061006e002000e50070006e006500730020006d006500640020004100630072006f0062006100740020006f0067002000520065006100640065007200200035002e00300020006f0067002000730065006e006500720065002e>
    /SVE <FEFF0041006e007600e4006e00640020006400650020006800e4007200200069006e0073007400e4006c006c006e0069006e006700610072006e00610020006e00e40072002000640075002000760069006c006c00200073006b0061007000610020005000440046002d0064006f006b0075006d0065006e007400200073006f006d00200070006100730073006100720020006600f600720020007000e5006c00690074006c006900670020007600690073006e0069006e00670020006f006300680020007500740073006b0072006900660074002000610076002000610066006600e4007200730064006f006b0075006d0065006e0074002e0020005000440046002d0064006f006b0075006d0065006e00740065006e0020006b0061006e002000f600700070006e006100730020006d006500640020004100630072006f0062006100740020006f00630068002000520065006100640065007200200035002e003000200065006c006c00650072002000730065006e006100720065002e>
    /ENU (IEEE Settings with Allen Press Trim size)
  >>
>> setdistillerparams
<<
  /HWResolution [600 600]
  /PageSize [567.000 774.000]
>> setpagedevice

